/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../formality/stdlib/_export_to_webpack_.js":
/*!**************************************************!*\
  !*** ../formality/stdlib/_export_to_webpack_.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arr     = __webpack_require__(/*! ./arr.fmc */ \"../formality/stdlib/arr.fmc\").default;\nvar bits    = __webpack_require__(/*! ./bits.fmc */ \"../formality/stdlib/bits.fmc\").default;\nvar bool    = __webpack_require__(/*! ./bool.fmc */ \"../formality/stdlib/bool.fmc\").default;\nvar cat     = __webpack_require__(/*! ./cat.fmc */ \"../formality/stdlib/cat.fmc\").default;\nvar global  = __webpack_require__(/*! ./global.fmc */ \"../formality/stdlib/global.fmc\").default;\nvar kaelin  = __webpack_require__(/*! ./kaelin.fmc */ \"../formality/stdlib/kaelin.fmc\").default;\nvar keccak  = __webpack_require__(/*! ./keccak.fmc */ \"../formality/stdlib/keccak.fmc\").default;\nvar list    = __webpack_require__(/*! ./list.fmc */ \"../formality/stdlib/list.fmc\").default;\nvar maybe   = __webpack_require__(/*! ./maybe.fmc */ \"../formality/stdlib/maybe.fmc\").default;\nvar main    = __webpack_require__(/*! ./main.fmc */ \"../formality/stdlib/main.fmc\").default;\nvar nat     = __webpack_require__(/*! ./nat.fmc */ \"../formality/stdlib/nat.fmc\").default;\nvar num     = __webpack_require__(/*! ./num.fmc */ \"../formality/stdlib/num.fmc\").default;\nvar pair    = __webpack_require__(/*! ./pair.fmc */ \"../formality/stdlib/pair.fmc\").default;\nvar pbt     = __webpack_require__(/*! ./pbt.fmc */ \"../formality/stdlib/pbt.fmc\").default;\nvar stack   = __webpack_require__(/*! ./stack.fmc */ \"../formality/stdlib/stack.fmc\").default;\nvar string  = __webpack_require__(/*! ./string.fmc */ \"../formality/stdlib/string.fmc\").default;\nvar term    = __webpack_require__(/*! ./term.fmc */ \"../formality/stdlib/term.fmc\").default;\nvar tree    = __webpack_require__(/*! ./tree.fmc */ \"../formality/stdlib/tree.fmc\").default;\nvar tup     = __webpack_require__(/*! ./tup.fmc */ \"../formality/stdlib/tup.fmc\").default;\nvar v2      = __webpack_require__(/*! ./v2.fmc */ \"../formality/stdlib/v2.fmc\").default;\n\nmodule.exports = [\n  arr,\n  bits,\n  bool,\n  cat,\n  global,\n  kaelin,\n  keccak,\n  list,\n  main,\n  maybe,\n  nat,\n  num,\n  pair,\n  pbt,\n  stack,\n  string,\n  term,\n  tree,\n  tup,\n  v2,\n].join(\"\\n\");\n\n\n\n//# sourceURL=webpack:///../formality/stdlib/_export_to_webpack_.js?");

/***/ }),

/***/ "../formality/stdlib/arr.fmc":
/*!***********************************!*\
  !*** ../formality/stdlib/arr.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Efficient \\\"C-like\\\" arrays using perfect binary trees\\n\\n// Example usage of this library\\ndef Arr.ex:\\n\\n  // Allocates a new array and creates its methods\\n  let dpt    = ~16\\n  let pbt    = PBT.16\\n  let add    = Num.boxed_add\\n  dup arr    = (Arr.init pbt #0)   // ~133k graph-rewrites to alloc 65536 zeros\\n  dup write  = (Arr.write dpt)  // ~650 graph-rewrites per write with dpt=16\\n  dup update = (Arr.update dpt) // ~650 graph-rewrites per update with dpt=16\\n  dup read   = (Arr.read dpt)   // ~650 graph-rewrites per read with dpt=16\\n\\n  // Performs some writes and reads\\n  # let arr      = (write 0 #10 arr)       // arr[0] = 10\\n    let arr      = (write 1 #12 arr)       // arr[1] = 12\\n    let arr      = (update 2 (add #8) arr) // arr[2] += 8\\n    let arr      = (write 3 #7 arr)        // arr[1] = 12\\n    get [arr, a] = (read 0 arr)            // a = arr[0]\\n    get [arr, b] = (read 1 arr)            // b = arr[1]\\n    get [arr, c] = (read 2 arr)            // c = arr[2]\\n    get [arr, d] = (read 3 arr)            // c = arr[2]\\n    [\\\"arr[0] + arr[1] + arr[2]:\\\", (add (add a b) c)]\\n\\n// Example of folding over an array\\ndef Arr.ex.fold:\\n  dup fold  = (Arr.fold PBT.3 #{a b}|a + b| #{x}|x * 2|)\\n  # (fold [[[1,2],[3,4]],[[5,6],[7,8]]])\\n\\n// Arr. with\\n// | Searches an element, updates it, returns the updated\\n// | array and a value that can depend on the element\\n// : {-A  : Type}             -- Type of the elements\\n//   {dpt : CNat}             -- Length of array = 2^dpt\\n//   ! {path : Num}           -- Num storing path to element\\n//     {fn   : {x : A} (A,A)} -- Receives found element, returns an element to replace it by, and a return value.\\n//     {(Array dpt A)}        -- The array to be queried\\n//     ((Array dpt A), A)     -- The updated array, and return value returned by `fn`.\\ndef Arr.with: {dpt}\\n  let init = {path fn} fn\\n  let loop = {cont path fn}\\n    cpy path = path\\n    get [swap0,swap1] =\\n      if |path % 2|\\n      then: [{x}x, {x}x]\\n      else: [Pair.swap, Pair.swap]\\n    (cont |path / 2| {arr}\\n      get [a,b] = (swap0 arr)\\n      get [b,x] = (fn b)\\n      [(swap1 [a,b]), x])\\n  let stop = {func} func\\n  dup fold = (for dpt #init #loop #stop)\\n  # {path fn arr} (fold path fn arr)\\n\\n// Arr.update\\n// | Applies a function to an element\\n// : {-A  : Type}             -- Type of the elements\\n//   {dpt : CNat}             -- Length of array = 2^dpt\\n//   ! {path : Num}           -- Num storing path to element\\n//     {fn   : {x : A} A}     -- Update function\\n//     {arr  : (Array dpt A)} -- The array to be updated\\n//     (Array dpt A)          -- The updated array, and return value returned by `fn`.\\ndef Arr.update: {dpt}\\n  dup with = (Arr.with dpt) \\n  # {path f arr} (fst (with path {x}[(f x), 0] arr))\\n\\n// Arr.read\\n// | Returns a copy of an element and returns the array unchanged\\n// : {-A  : Type}              -- Type of the elements\\n//   {dpt : CNat}              -- Length of array = 2^dpt\\n//   ! {path : Num}            -- Num storing path to element\\n//     {arr  : (Array dpt !A)} -- The array to be read\\n//     {(Array dpt !A),!A}    -- The array itself, and a copy of the element\\ndef Arr.read: {dpt}\\n  dup with = (Arr.with dpt)\\n  # {path arr}\\n    let f = {x}\\n      dup x = x\\n      [#x, #x]\\n    (with path f arr)\\n\\n// peek\\n// | Like read, but on numeric, unboxed arrays\\n// : {-A  : Type}               -- Type of the elements\\n//   {dpt : CNat}               -- Length of array = 2^dpt\\n//   ! {path : Num}             -- Num storing path to element\\n//     {arr  : (Array dpt Num)} -- The array to be read\\n//     {(Array dpt Num), Num}   -- The array itself, and a copy of the element\\ndef Arr.peek: {dpt}\\n  dup with = (Arr.with dpt)\\n  # {path arr}\\n    let f = {x}\\n      cpy x = x\\n      [x, x]\\n    (with path f arr)\\n\\n// Arr.take\\n// | Takes an element out of an array and returns it\\n// : {-A  : Type}             -- Type of the elements\\n//   {dpt : CNat}             -- Length of array = 2^dpt\\n//   ! {path : Num}           -- Num storing path to element\\n//     {val  : A}             -- New value to put in place of old\\n//     {arr  : (Array dpt A)} -- The array to be taken\\n//     {(Array dpt A),A}      -- The updated array and the take element\\ndef Arr.take: {dpt}\\n  dup with = (Arr.with dpt)\\n  # {path val arr}\\n    (with path {x}[val,x] arr)\\n\\n// Arr.write\\n// | Overwrites an element of the array\\n// : {-A  : Type}             -- Type of hte elements\\n//   {dpt : CNat}             -- Length of the array = 2^dpt\\n//   ! {path : Num}           -- Num storing path to element\\n//     {arr  : (Array dpt A)} -- Array to be written\\n//     {val  : A}             -- Value to be written\\n//     (Array dpt A)          -- The overwritten array\\ndef Arr.write: {dpt}\\n  dup update = (Arr.update dpt)\\n  # {path val} (update path {x}val)\\n\\n// Arr.test_1024\\n// : (Array ~10 Num)\\ndef Arr.test_1024:\\n  let a = [1,1]\\n  let b = [a,a]\\n  let c = [b,b]\\n  let d = [c,c]\\n  let e = [d,d]\\n  let f = [e,e]\\n  let g = [f,f]\\n  let h = [g,g]\\n  let i = [h,h]\\n  [i,i]\\n\\n// Arr.fold\\n// : {-A  : Type}\\n//   {-P   : Type}\\n//   {dpt  : PBT}\\n//   {Node : !{lft : A} {rgt : A} P}\\n//   {Leaf : !{val : A} P}\\n//   ! {arr  : !(Array dpt A)}\\n//     P\\ndef Arr.fold: {pbt Node Leaf}\\n  dup Node = Node\\n  dup Leaf = Leaf\\n  let leaf = # {val} (Leaf val)\\n  let node = # {lft rgt arr}\\n    get [arr_lft, arr_rgt] = arr\\n    (Node (lft arr_lft) (rgt arr_rgt))\\n  (pbt node leaf)\\n\\n// Arr.init\\n// | Generates an array with 2^dpt copies of val\\n// : {-A  : Type}\\n//   {dpt : PBT}\\n//   {val : !A}\\n//   ! (Array dpt A)\\ndef Arr.init: {dpt val}\\n  dup val = val\\n  (dpt #{a b}[a,b] #val)\\n\\ndef arr: Arr.ex\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/arr.fmc?");

/***/ }),

/***/ "../formality/stdlib/bits.fmc":
/*!************************************!*\
  !*** ../formality/stdlib/bits.fmc ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Bits.ex\\n// | This example achieves the fusion effect in a recursive function. In order\\n// | for the optimization to work (allowing us to apply `Bits.inc` N times in\\n// | O(log(N)) time, an exponential speedup), we need to call `Bits.id`\\n// | afterwards, otherwise we get back to O(N).\\ndef Bits.ex:\\n  let len = ~32\\n  dup val = (rec len #Bits.o #Bits.e)\\n  dup inc = (Bits.inc len)\\n  dup bid = (Bits.id len)\\n  dup fun = (~1000000 #inc)\\n  # (bid (fun val))\\n\\n// Bits\\n// | Bitstrings\\n// : $self\\n//   {P : Bits -> Type} ->\\n//   {o : {bs : Bits} -> (P (Bits.o bs))} ->\\n//   {i : {bs : Bits} -> (P (Bits.i bs))} ->\\n//   {e : (P Bits.e)}\\n//   (P self)\\ndef Bits.o: {bs} {o i e} (o bs)\\ndef Bits.i: {bs} {o i e} (i bs)\\ndef Bits.e:      {o i e} e\\n\\n// Bits.inc\\n// | Increments a bit-string by 1\\n// : {n : Nat} ->\\n//   ! {bs : Bits} ->\\n//     Bits\\ndef Bits.inc: {n}\\n  let call = {go bs} {o i e}\\n    let case_o = i\\n    let case_i = {x} (o (go x))\\n    let case_e = e\\n    (bs case_o case_i case_e)\\n  let stop = {bs} bs\\n  (rec n #call #stop)\\n\\n// Bits.id\\n// | Returns the same bit-string\\n// : {n : Nat} ->\\n//   ! {bs : Bits} ->\\n//     Bits\\ndef Bits.id: {n}\\n  let call = {go bs}\\n    let case_o = {x go} (Bits.o (go x))\\n    let case_i = {x go} (Bits.i (go x))\\n    let case_e = {go} Bits.e\\n    (bs case_o case_i case_e go)\\n  let stop = {bs} bs\\n  (rec n #call #stop)\\n\\ndef Bits.to_chars: {n}\\n  let call = {go bs}\\n    let case_o = {x go} (List.concat (to_chars \\\"o\\\") (go x))\\n    let case_i = {x go} (List.concat (to_chars \\\"i\\\") (go x))\\n    let case_e = {go} List.nil\\n    (bs case_o case_i case_e go)\\n  let stop = {bs} List.nil\\n  (rec n #call #stop)\\n\\ndef Bits.to_string: {n}\\n  dup to_chars = (Bits.to_chars n)\\n  # {bits} (from_chars (to_chars bits))\\n\\ndef Bits.to_cat: {n}\\n  let call = {go bits} (bits\\n    {bs} {go} (Cat.mul ~2 (go bs))\\n    {bs} {go} (Cat.succ (Cat.mul ~2 (go bs)))\\n    {go} ~0\\n    go)\\n  let stop = {bits} ~0\\n  (rec n #call #stop)\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/bits.fmc?");

/***/ }),

/***/ "../formality/stdlib/bool.fmc":
/*!************************************!*\
  !*** ../formality/stdlib/bool.fmc ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// | This example achieves the fusion effect in a simple function, applying\\n// | `not` `N` times to `true` in `O(log(N))` time.\\ndef Bool.ex:\\n  dup val = Bool.true\\n  dup fun = (~100000000 #Bool.not)\\n  # (fun val)\\n\\n// Bool\\n// | Booleans\\n// : $self\\n//   {P : Bool -> Type} ->\\n//   {o : (P Bool.true)} ->\\n//   {i : (P Bool.false)} ->\\n//   (P self)\\ndef Bool.true:  {t f} t\\ndef Bool.false: {t f} f\\n\\n// Bool.not\\n// | Boolean negation\\n// : {b : Bool} -> Bool\\ndef Bool.not: {b}\\n  {t f} (b f t)\\n\\n// Bool.eql\\n// | Boolean equality\\n// : {b : Bool} -> Bool\\ndef Bool.eql: {a b}\\n  (a {x}x not b)\\n\\n// TODO: many other Bool functions\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/bool.fmc?");

/***/ }),

/***/ "../formality/stdlib/cat.fmc":
/*!***********************************!*\
  !*** ../formality/stdlib/cat.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Church Natural Numbers\\n\\n// Computes `123^1000 mod 137` in `6m` graph-rewrites.\\ndef Cat.ex:\\n  let a = ~123\\n  let x = ~1000\\n  let N = ~137\\n  (exp_mod #a x #N)\\n\\ndef Cat.zero: {s}\\n  # {z} z\\n\\ndef Cat.succ: {n} {s}\\n  dup s = s\\n  dup f = (n #s)\\n  # {z} (s (f z))\\n\\ndef Cat.mul: {a b} {s} \\n  dup s = s\\n  dup f = (a (b #s))\\n  # {z} (f z)\\n\\n// Computes `a^x`\\ndef Cat.exp: {a x}\\n  (x a)\\n\\n// Cat.to_nat\\n// : {c : Cat} ->\\n//   Nat\\ndef Cat.to_nat: {n}\\n  let init = Zero\\n  let loop = Succ\\n  let stop = {x}x\\n  (for n #init #loop #stop)\\n\\n// Cat.exp_mod\\n// | Computes `a^x mod n` (fast modular exponentiation with optimal reductions).\\n// : {a : !Cat}\\n//   {x : Cat}\\n//   {N : !Cat}\\n//   ! Cat\\ndef Cat.exp_mod: {a x N}\\n\\n  // Computes a^x\\n  dup ax = (exp a x)\\n\\n  // Creates copies of N\\n  dup N  = N\\n\\n  # // Creates an N-tuple with numbers from N-1 down to 0\\n    dup numbers = (Tup.rev_range N) \\n\\n    // Creates a function to get the last element of an N-tuple\\n    dup get_last = (Tup.last N)\\n\\n    // Creates a function that rotates an N-tuple rightwise `ax` times\\n    dup rotate_ax_times = (ax (Tup.rotate_right N))\\n\\n    // Rotates the numbers and returns the last element, i.e., `a^x mod N`\\n    # (get_last (rotate_ax_times numbers))\\n\\ndef Cat.to_bits: {n x}\\n  dup bid  = (Bits.id ~n)\\n  dup inc  = (Bits.inc ~n)\\n  dup bits = (rec ~n #Bits.o #Bits.e)\\n  dup func = (n #inc)\\n  # (bid (func bits))\\n\\ndef Cat.to_string: {n}\\n  dup chars = (rec n #{x}(List.concat (to_chars \\\"S\\\") x) #(to_chars \\\"Z\\\"))\\n  # (from_chars chars)\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/cat.fmc?");

/***/ }),

/***/ "../formality/stdlib/global.fmc":
/*!**************************************!*\
  !*** ../formality/stdlib/global.fmc ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Terms so common that they \\\"deserve\\\" a global, non-namespaced name\\n\\n// Bounded function.\\ndef rec: {nat call stop}\\n  dup callN = (nat call)\\n  dup stop  = stop\\n  # (callN stop)\\n\\n// Bounded for-loop\\ndef for: {nat init loop stop}\\n  dup init = init\\n  dup exec = (nat loop)\\n  dup stop = stop\\n  # (stop (exec init))\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/global.fmc?");

/***/ }),

/***/ "../formality/stdlib/kaelin.fmc":
/*!**************************************!*\
  !*** ../formality/stdlib/kaelin.fmc ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// ## Kaelin\\n// \\n// A simple, blockhain-enabled MOBA implemented in Formality-Core.\\n// \\n// Kaelin aims to capture some of the spirit of a MOBA, inluding map awareness,\\n// micro and macro strategies, resource control, team-fights, skillshots and so\\n// on, while aiming blockchain-compatible by being very lightweight (the entire\\n// game state has only 8192 bits) and based on ~20 second turns. This allows it\\n// to run on state-channels and use Ethereum for conflict resolution.\\n// \\n// ## Heroes\\n// \\n// Name    | Role   | Description    | MOV | HP  | References & Inspiration\\n// ------- | ------ | -------------- | --- | --- | -------------------------------------------------\\n// Tophoro | Tank   | Terrain Bender |   3 |  60 | Toph (Avatar TLA), Totoro (Studio Ghibli)\\n// Gonk    | Tank   | Warrior        |   3 |  40 | Gon (Hunter X Hunter), Goku (Gradon Ball Z)\\n// Stanci  | Tank   | Healer         |   3 |  40 | Dev\\n// ?????   | Tank   |                |     |     | \\n// Erkos   | Ranged | Fire Mage      |   3 |  20 | Erk (Fire Emblem), Harry Potter (Harry Potter)\\n// Croni   | Ranged | Dark Mage      |   3 |  20 | Chromie (Blizzard), Raven (Teen Titans)\\n// Snarch  | Ranged | Archer         |   3 |  20 | Zk-Snarks (crypto)\\n// ?????   | Ranged | ?              |     |     |\\n// Sirpix  | Melee  | Thief          |   3 |  30 | Dev\\n// Kenlua  | Melee  | Swordsman      |   3 |  30 | Killua (Hunter X Hunter), Kenshin (Rurouni Kenshin)\\n// Flina   | Melee  | Pegasus Knight |   3 |  30 | Florina (Fire Emblem), Link (The Legend of Zelda)\\n// ?????   | Melee  | ?              |   3 |  30 | ????\\n// Zagatur | Tactic | Summoner       |   0 |   4 | Zagara, Abathur (Blizzard)\\n// Agdris  | Tactic | Silencer       |   2 |  10 | Agda, Idris (programming language)\\n// Mewem   | Tactic | Psychic        |   0 |  10 | Mewtwo (PokÃ©mon), Meruem (Hunter X Hunter)\\n// ?????   | Tactic | ?              |   ? |  ?? | ????\\n//\\n// ## Moves\\n// \\n// HERO    | MOVE           | EFFECT\\n// ------- | -------------- | ------\\n// TOPHORO | Earth_Root     | Heals 20 hp. Self-roots for 3 turns. Fast.\\n// TOPHORO | Earth_Wall     | Range: 2. Area: 1. Places a temporary wall. Fast.\\n// TOPHORO | Earth_Rise     | Range: 2. Area: 1. Damage: 2. Mutes.\\n// GONK    | Empathy        | Range: 1. Area: 1. Armor: 5. Fast. Loses 2 HP.\\n// GONK    | Revenge        | Range: 1. Area: 0. Fast. Damage: `missing_hp / 4`. Fast.\\n// GONK    | Ground_Slam    | Range: 0. Area: 2. Damage: 2. Mutes.\\n// STANCI  | Restore        | Range: 3. Area: 0. Heal: 3. Fast.\\n// STANCI  | Escort         | Range: 3. Area: 0. Armor: 3. Fast.\\n// STANCI  | Detain         | Range: 3. Area: 0. Mutes. Fast.\\n// ?       |                |\\n// ?       |                |\\n// ?       |                |\\n// ERKOS   | Flame_Ball     | Range: 3. Area: 2. Damage: 3.\\n// ERKOS   | Flame_Wave     | Range: 3. Area: 1. Damage: 5.\\n// ERKOS   | Flame_Nova     | Range: 0. Area: 6. Damage: 15. Loses 30 HP.\\n// CRONI   | Shadow_Bond    | Fast. Loses 3 HP. If enemy at given position kills Croni this turn, it dies too.\\n// CRONI   | Shadow_Trap    | Range: 6. Area: 0. Fast. Places a trap that locks whoever steps on it.\\n// CRONI   | Shadow_Flux    | Range: 6. Area: 1. Damage: 8.\\n// SNARCH  | Ballista       | Mounts from a ballista, doubling Snarch's range and locking him. Can't attack on this turn.\\n// SNARCH  | Quick_Bolt_0   | Range: 5. Area: 0. Damage: 2. Fast.\\n// SNARCH  | Quick_Bolt_1   | Range: 5. Area: 0. Damage: 2. Fast.\\n// ?       |                |\\n// ?       |                |\\n// ?       |                |\\n// SIRPIX  | Stealth_Move   | Moves your Stealth Clone up to 3 range.\\n// SIRPIX  | Stealth_Strike | Range: 0. Area: 0. Damage: 3. Before attacking, swaps position with your Stealth Clone.\\n// SIRPIX  | Lockpick       | Special effects on map.\\n// KENLUA  | Haste          | Range: 3. Area: 0. Loses 1 hp. Blinks to target. Range: 0. Area: 1. Damage: 4.\\n// KENLUA  | Dodge          | Range: 32. Can't take damage from target during this turn.\\n// KENLUA  | Slash          | Range: 1. Area: 0. Damage: 12.\\n// FLINA   | Javelin        | Range: 2. Area: 0. Damage: 4. Fast.\\n// FLINA   | Fly            | Range: 3. Area: 0. Blinks to target.\\n// FLINA   | Gust           | Range: 2. Area: 1. Damage: 3.\\n// ?       |                |\\n// ?       |                |\\n// ?       |                |\\n// ZAGATUR | Wrap           | Range: 0. Area: 1. Fast. Locks.\\n// ZAGATUR | Needle         | Range: 0. Area: 1. Damage: 3.\\n// ZAGATUR | Summon         | Range: 3. Spawns a clone of Zagatur.\\n// AGDRIS  | Memento        | Range: 32. Area: 2. Damage: 2. Fast. Heal: 2. Armor: 2. Locks. Mutes. Dies.\\n// AGDRIS  | Silence        | Range: 32. Area: 0. Mutes.\\n// AGDRIS  | Protect        | Range: 32. Area: 0. Armor: 3.\\n// MEWRU   | Teleport       | Range: 32. Fast. Blinks to target.\\n// MEWRU   | Psychock       | hits a 3x3 area up to 4 range, dealing 6 damage.\\n// MEWRU   | Imprison       | hits a 3x3 area up to 4 range, locking enemies.\\n// ?       |                |\\n// ?       |                |\\n// ?       |                |\\n// \\n// Hero    | Skill F           | Skill D             | Skill S\\n// ------- | ----------------- | ------------------- | -----------------\\n// TOPHORO | Earth_Root        | Earth_Wall          | Earth_Rise     \\n// GONK    | Empathy           | Revenge             | Ground_Slam     \\n// STANCI  | Restore           | Escort              | Detain     \\n// ERKOS   | Flame_Ball        | Flame_Wave          | Flame_Nova     \\n// CRONI   | Shadow_Bond       | Shadow_Trap         | Shadow_Flux     \\n// SNARCH  | Ballista          | Quick_Bolt_0        | Quick_Bolt_1\\n// SIRPIX  | Stealth_Move      | Stealth_Strike      | Lockpick     \\n// KENLUA  | Haste             | Dodge               | Slash     \\n// FLINA   | Javelin           | Fly                 | Gust\\n// ZAGATUR | Wrap              | Needle              | Summon     \\n// AGDRIS  | Memento           | Silence             | Protect     \\n// MEWRU   | Teleport          | Psychock            | Imprison     \\n\\ndef kaelin:\\n\\n  // :::::::::::\\n  // :: Array ::\\n  // :::::::::::\\n\\n  let fold4   = (Arr.fold PBT.4)\\n  let fold6   = (Arr.fold PBT.6)\\n  let fold8   = (Arr.fold PBT.8)\\n  let init4   = (Arr.init PBT.4)\\n  let init6   = (Arr.init PBT.6)\\n  let init8   = (Arr.init PBT.8)\\n  dup with4   = (Arr.with ~4)\\n  dup take4   = (Arr.take ~4)\\n  dup update4 = (Arr.update ~4)\\n  dup write4  = (Arr.write ~4)\\n  dup with6   = (Arr.with ~6)\\n  dup take6   = (Arr.take ~6)\\n  dup update6 = (Arr.update ~6)\\n  dup write6  = (Arr.write ~6)\\n  dup with8   = (Arr.with ~8)\\n  dup take8   = (Arr.take ~8)\\n  dup update8 = (Arr.update ~8)\\n  dup write8  = (Arr.write ~8)\\n\\n  // :::::::::::::::\\n  // :: Direction ::\\n  // :::::::::::::::\\n\\n  dup RIGHT = #[ 1, 0]\\n  dup DOWN  = #[ 0, 1]\\n  dup LEFT  = #[-1, 0]\\n  dup UP    = #[ 0,-1]\\n\\n  // ::::::::::\\n  // :: Side ::\\n  // ::::::::::\\n\\n  dup WHITE = # 0\\n  dup BLACK = # 1\\n  dup BOARD = # 2\\n\\n  dup is_enemy_side = # {a b}\\n    cpy a = a\\n    cpy b = b\\n    |||a == WHITE| & |b == BLACK|| | ||a == BLACK| & |b == WHITE|||\\n    \\n  dup is_ally_side = # {a b}\\n    cpy a = a\\n    cpy b = b\\n    |||a == WHITE| & |b == WHITE|| | ||a == BLACK| & |b == BLACK|||\\n\\n  // ::::::::::\\n  // :: Hero ::\\n  // ::::::::::\\n\\n  dup TOPHORO  = # 0\\n  dup GONK     = # 1\\n  dup STANCI   = # 2\\n  dup HERO_3   = # 3\\n  dup ERKOS    = # 4\\n  dup CRONI    = # 5\\n  dup SNARCH   = # 6\\n  dup HERO_7   = # 7\\n  dup SIRPIX   = # 8\\n  dup KENLUA   = # 9\\n  dup FLINA    = # 10\\n  dup HERO_B   = # 11\\n  dup ZAGATUR  = # 12\\n  dup AGDRIS   = # 13\\n  dup MEWEM    = # 14\\n  dup HERO_F   = # 15\\n\\n  // Given a hero, returns its icon\\n  dup get_hero_icon = # {hero}\\n    let hero00 = (to_chars \\\"To\\\")\\n    let hero01 = (to_chars \\\"Go\\\")\\n    let hero02 = (to_chars \\\"St\\\")\\n    let hero03 = (to_chars \\\"??\\\")\\n    let hero04 = (to_chars \\\"Er\\\")\\n    let hero05 = (to_chars \\\"Cr\\\")\\n    let hero06 = (to_chars \\\"Sn\\\")\\n    let hero07 = (to_chars \\\"??\\\")\\n    let hero08 = (to_chars \\\"Si\\\")\\n    let hero09 = (to_chars \\\"Ke\\\")\\n    let hero10 = (to_chars \\\"Fl\\\")\\n    let hero11 = (to_chars \\\"??\\\")\\n    let hero12 = (to_chars \\\"Za\\\")\\n    let hero13 = (to_chars \\\"Ag\\\")\\n    let hero14 = (to_chars \\\"Me\\\")\\n    let hero15 = (to_chars \\\"??\\\")\\n    let half00 = [[[hero00,hero01],[hero02,hero03]],[[hero04,hero05],[hero06,hero07]]]\\n    let half01 = [[[hero08,hero09],[hero10,hero11]],[[hero12,hero13],[hero14,hero15]]]\\n    let heroes = [half00, half01]\\n    (snd (take4 hero List.nil heroes))\\n\\n  // Given a hero, returns its max life\\n  dup get_hero_max_life = # {hero}\\n    let hero00 = 60\\n    let hero01 = 40\\n    let hero02 = 40\\n    let hero03 = 0\\n    let hero04 = 20\\n    let hero05 = 20\\n    let hero06 = 20\\n    let hero07 = 0\\n    let hero08 = 30\\n    let hero09 = 30\\n    let hero10 = 30\\n    let hero11 = 0\\n    let hero12 = 1\\n    let hero13 = 10\\n    let hero14 = 10\\n    let hero15 = 0\\n    let half00 = [[[hero00,hero01],[hero02,hero03]],[[hero04,hero05],[hero06,hero07]]]\\n    let half01 = [[[hero08,hero09],[hero10,hero11]],[[hero12,hero13],[hero14,hero15]]]\\n    let heroes = [half00, half01]\\n    (snd (take4 hero List.nil heroes))\\n\\n  // :::::::::::\\n  // :: Skill ::\\n  // :::::::::::\\n\\n  dup TOPHORO_WALK   = # 0\\n  dup EARTH_ROOT     = # 1\\n  dup EARTH_WALL     = # 2\\n  dup EARTH_RISE     = # 3\\n  dup GONK_WALK      = # 4\\n  dup EMPATHY        = # 5\\n  dup REVENGE        = # 6\\n  dup GROUND_SLAM    = # 7\\n  dup STANCI_WALK    = # 8\\n  dup RESTORE        = # 9\\n  dup ESCORT         = # 10\\n  dup DETAIN         = # 11\\n  dup ERKOS_WALK     = # 16\\n  dup FLAME_BALL     = # 17\\n  dup FLAME_WAVE     = # 18\\n  dup FLAME_NOVA     = # 19\\n  dup CRONI_WALK     = # 20\\n  dup SHADOW_BOND    = # 21\\n  dup SHADOW_TRAP    = # 22\\n  dup SHADOW_FLUX    = # 23\\n  dup SNARCH_WALK    = # 24\\n  dup BALLISTA       = # 25\\n  dup QUICK_BOLT_0   = # 26\\n  dup QUICK_BOLT_1   = # 27\\n  dup SIRPIX_WALK    = # 32\\n  dup STEALTH_MOVE   = # 33\\n  dup STEALTH_STRIKE = # 34\\n  dup LOCKPICK       = # 35\\n  dup KENLUA_WALK    = # 36\\n  dup HASTE          = # 37\\n  dup DODGE          = # 38\\n  dup SLASH          = # 39\\n  dup FLINA_WALK     = # 40\\n  dup JAVELIN        = # 41\\n  dup FLY            = # 42\\n  dup GUST           = # 43\\n  dup ZAGATUR_WALK   = # 48\\n  dup NEEDLE         = # 49\\n  dup WRAP           = # 50\\n  dup SUMMON         = # 51\\n  dup AGDRIS_WALK    = # 52\\n  dup PROTECT        = # 53\\n  dup SILENCE        = # 54\\n  dup MEMENTO        = # 55\\n  dup MEWEN_WALK     = # 56\\n  dup TELEPORT       = # 57\\n  dup PSYCHOCK       = # 58\\n  dup IMPRISON       = # 59\\n\\n  dup PRIORITY_LIST = #\\n    (Stack.push MEMENTO\\n    (Stack.push SILENCE\\n    (Stack.push PROTECT\\n    (Stack.push STEALTH_MOVE\\n    (Stack.push TELEPORT\\n    (Stack.push EARTH_ROOT\\n    (Stack.push SHADOW_BOND\\n    (Stack.push BALLISTA\\n    (Stack.push EMPATHY\\n    (Stack.push ESCORT\\n    (Stack.push RESTORE\\n    (Stack.push DETAIN\\n    (Stack.push HASTE\\n    (Stack.push STEALTH_STRIKE\\n    (Stack.push REVENGE\\n    (Stack.push JAVELIN\\n    (Stack.push QUICK_BOLT_0\\n    (Stack.push QUICK_BOLT_1\\n    (Stack.push EARTH_WALL\\n    (Stack.push SHADOW_TRAP\\n    (Stack.push WRAP\\n    (Stack.push KENLUA_WALK\\n    (Stack.push SIRPIX_WALK\\n    (Stack.push FLINA_WALK\\n    (Stack.push SNARCH_WALK\\n    (Stack.push ERKOS_WALK\\n    (Stack.push CRONI_WALK\\n    (Stack.push STANCI_WALK\\n    (Stack.push GONK_WALK\\n    (Stack.push TOPHORO_WALK\\n    (Stack.push AGDRIS_WALK\\n    (Stack.push MEWEN_WALK\\n    (Stack.push ZAGATUR_WALK\\n    (Stack.push FLY\\n    (Stack.push DODGE\\n    (Stack.push NEEDLE\\n    (Stack.push EARTH_RISE\\n    (Stack.push GROUND_SLAM\\n    (Stack.push GUST\\n    (Stack.push SLASH\\n    (Stack.push FLAME_WAVE\\n    (Stack.push FLAME_BALL\\n    (Stack.push FLAME_NOVA\\n    (Stack.push PSYCHOCK\\n    (Stack.push IMPRISON\\n    (Stack.push SHADOW_FLUX\\n    (Stack.push LOCKPICK\\n    (Stack.push SUMMON\\n    Stack.new))))))))))))))))))))))))))))))))))))))))))))))))\\n\\n  let get_skill_area = {skill}\\n    cpy skill = skill\\n    if |skill ==  2| then: 1\\n    else: if |skill ==  3| then: 1\\n    else: if |skill ==  5| then: 1\\n    else: if |skill ==  7| then: 2\\n    else: if |skill == 17| then: 2\\n    else: if |skill == 18| then: 1\\n    else: if |skill == 19| then: 6\\n    else: if |skill == 23| then: 1\\n    else: if |skill == 43| then: 1\\n    else: if |skill == 49| then: 1\\n    else: if |skill == 50| then: 1\\n    else: if |skill == 53| then: 2\\n    else: if |skill == 58| then: 1\\n    else: if |skill == 59| then: 1\\n    else: 0\\n\\n  dup get_skill_priority =\\n    dup build_array = (~64 #{state}\\n      get [array, state]  = state\\n      get [index, skills] = state\\n      get [skills, skill] = (Stack.pop 63 skills)\\n      cpy index           = index\\n      let array           = (write6 skill index array)\\n      [array, [|index + 1|, skills]])\\n    dup empty_array = (init6 #0)\\n    # {skill}\\n      let array = fst (build_array [empty_array, [0, PRIORITY_LIST]])\\n      snd (take6 skill 0 array)\\n\\n  // ::::::::::\\n  // :: Item ::\\n  // ::::::::::\\n\\n  dup WALL = # 0\\n  dup ROCK = # 1\\n  dup TRAP = # 2\\n\\n  // ::::::::::\\n  // :: Unit ::\\n  // ::::::::::\\n\\n  dup VOID = # 0\\n  dup ITEM = # 1\\n  dup GOAL = # 2\\n  dup HERO = # 3\\n\\n  // Unit getters\\n  dup get_unit_kind = # {unit} ||unit >> 30| & 0b00000011|\\n  dup get_unit_side = # {unit} ||unit >> 28| & 0b00000011|\\n  dup get_unit_type = # {unit} ||unit >> 26| & 0b00000011|\\n  dup get_unit_hero = # {unit} ||unit >> 24| & 0b00001111|\\n  dup get_unit_life = # {unit} ||unit >> 18| & 0b00111111|\\n  dup get_unit_defs = # {unit} ||unit >> 14| & 0b00001111|\\n  dup get_unit_eff1 = # {unit} ||unit >> 12| & 0b00000011|\\n  dup get_unit_lock = # {unit} ||unit >> 10| & 0b00000011|\\n  dup get_unit_mute = # {unit} ||unit >>  8| & 0b00000011|\\n  dup get_unit_spec = # {unit} ||unit >>  0| & 0b11111111|\\n\\n  // Unit setters\\n  dup set_unit_kind = # {kind unit} ||unit & 0b00111111111111111111111111111111| | ||kind & 0b00000011| << 30||\\n  dup set_unit_side = # {side unit} ||unit & 0b11001111111111111111111111111111| | ||side & 0b00000011| << 28||\\n  dup set_unit_type = # {type unit} ||unit & 0b11110011111111111111111111111111| | ||type & 0b00000011| << 26||\\n  dup set_unit_hero = # {hero unit} ||unit & 0b11110000111111111111111111111111| | ||hero & 0b00001111| << 24||\\n  dup set_unit_life = # {life unit} ||unit & 0b11111111000000111111111111111111| | ||life & 0b00111111| << 18||\\n  dup set_unit_defs = # {defs unit} ||unit & 0b11111111111111000011111111111111| | ||defs & 0b00001111| << 14||\\n  dup set_unit_eff1 = # {eff1 unit} ||unit & 0b11111111111111111100111111111111| | ||eff1 & 0b00000011| << 12||\\n  dup set_unit_lock = # {lock unit} ||unit & 0b11111111111111111111001111111111| | ||lock & 0b00000011| << 10||\\n  dup set_unit_mute = # {mute unit} ||unit & 0b11111111111111111111110011111111| | ||mute & 0b00000011| <<  8||\\n  dup set_unit_spec = # {spec unit} ||unit & 0b11111111111111111111111100000000| | ||spec & 0b11111111| <<  0||\\n\\n  // Unit mappers\\n  dup mut_unit_kind = # {func unit} cpy unit = unit (set_unit_kind (func (get_unit_kind unit)) unit)\\n  dup mut_unit_type = # {func unit} cpy unit = unit (set_unit_type (func (get_unit_type unit)) unit)\\n  dup mut_unit_side = # {func unit} cpy unit = unit (set_unit_side (func (get_unit_side unit)) unit)\\n  dup mut_unit_hero = # {func unit} cpy unit = unit (set_unit_hero (func (get_unit_hero unit)) unit)\\n  dup mut_unit_life = # {func unit} cpy unit = unit (set_unit_life (func (get_unit_life unit)) unit)\\n  dup mut_unit_defs = # {func unit} cpy unit = unit (set_unit_defs (func (get_unit_defs unit)) unit)\\n  dup mut_unit_eff1 = # {func unit} cpy unit = unit (set_unit_eff1 (func (get_unit_eff1 unit)) unit)\\n  dup mut_unit_lock = # {func unit} cpy unit = unit (set_unit_lock (func (get_unit_lock unit)) unit)\\n  dup mut_unit_mute = # {func unit} cpy unit = unit (set_unit_mute (func (get_unit_mute unit)) unit)\\n  dup mut_unit_spec = # {func unit} cpy unit = unit (set_unit_spec (func (get_unit_spec unit)) unit)\\n\\n  // Unit constructor\\n  dup Unit = # {kind}\\n    cpy kind = kind\\n    cpy unit = 0\\n    if |kind == VOID| then:\\n      let unit = (set_unit_kind VOID unit) \\n      let unit = (set_unit_side BOARD unit)\\n      unit\\n    else: if |kind == ITEM| then: {type}\\n      let unit = (set_unit_kind ITEM unit)\\n      let unit = (set_unit_side BOARD unit)\\n      let unit = (set_unit_type type unit)\\n      unit\\n    else: if |kind == GOAL| then: {side}\\n      let unit = (set_unit_kind GOAL unit)\\n      let unit = (set_unit_side side unit)\\n      unit\\n    else: if |kind == HERO| then: {side hero life defs eff1 lock mute spec}\\n      let unit = (set_unit_kind HERO unit)\\n      let unit = (set_unit_side side unit)\\n      let unit = (set_unit_hero hero unit)\\n      let unit = (set_unit_life life unit)\\n      let unit = (set_unit_defs defs unit)\\n      let unit = (set_unit_eff1 eff1 unit)\\n      let unit = (set_unit_lock lock unit)\\n      let unit = (set_unit_mute mute unit)\\n      let unit = (set_unit_spec spec unit)\\n      unit\\n    else:\\n      unit\\n\\n  // Void constructor\\n  dup Void = #\\n    (Unit VOID)\\n\\n  // Item constructor\\n  dup Item = # {type}\\n    (Unit ITEM type)\\n\\n  // Goal constructor\\n  dup Goal = # {side}\\n    (Unit GOAL side)\\n\\n  // Hero constructor\\n  dup Hero = # {side hero}\\n    cpy hero = hero\\n    (Unit HERO side hero (get_hero_max_life hero) 0 0 0 0 0)\\n\\n  // Unit kind pattern-matching\\n  dup match_unit_kind = # {unit case_void case_item case_goal case_hero}\\n    cpy unit = unit \\n    cpy kind = (get_unit_kind unit)\\n    if |kind == VOID| then:\\n      case_void\\n    else: if |kind == ITEM| then:\\n      case_item\\n    else: if |kind == GOAL| then:\\n      case_goal\\n    else: if |kind == HERO| then:\\n      case_hero\\n    else:\\n      0\\n\\n  dup unit_to_scott = # {unit}\\n    cpy unit      = unit\\n    let case_void = {Void Item Goal Hero}\\n      Void\\n    let case_item = {Void Item Goal Hero}\\n      (Item (get_unit_type unit))\\n    let case_goal = {Void Item Goal Hero}\\n      (Goal (get_unit_side unit))\\n    let case_hero = {Void Item Goal Hero}\\n      (Hero\\n        (get_unit_side unit)\\n        (get_unit_hero unit)\\n        (get_unit_life unit)\\n        (get_unit_defs unit)\\n        (get_unit_eff1 unit)\\n        (get_unit_lock unit)\\n        (get_unit_mute unit)\\n        (get_unit_spec unit))\\n    (match_unit_kind unit case_void case_item case_goal case_hero)\\n\\n  // Given a unit, returns its icon\\n  dup get_unit_icon = # {unit}\\n    cpy unit      = unit\\n    let case_void = (to_chars \\\" .\\\")\\n    let case_item = cpy t = (get_unit_type unit) if |t == WALL| [(to_chars \\\"[]\\\"), if |t == ROCK| [(to_chars \\\"()\\\"), (to_chars \\\" %\\\")]]\\n    let case_goal = (to_chars \\\"<>\\\")\\n    let case_unit = (get_hero_icon (get_unit_hero unit))\\n    (match_unit_kind unit case_void case_item case_goal case_unit)\\n\\n  // Given a unit, returns a readable stats line\\n  dup get_unit_info = # {unit}\\n    cpy unit      = unit\\n    let case_void = List.nil\\n    let case_item = List.nil\\n    let case_goal = List.nil\\n    let case_hero =\\n      cpy hero = (get_unit_hero unit)\\n      cpy side = (get_unit_side unit)\\n      cpy life = (get_unit_life unit)\\n      cpy defs = (get_unit_defs unit)\\n      cpy eff1 = (get_unit_eff1 unit)\\n      cpy lock = (get_unit_lock unit)\\n      cpy mute = (get_unit_mute unit)\\n      cpy spec = (get_unit_spec unit)\\n      (List.concat (get_hero_icon hero) // Hero name\\n      (List.concat (to_chars \\\" | \\\")\\n      (List.concat (List.cons (Num.box_byte (Num.to_char ||life /  10| % 10|)) List.nil) // life\\n      (List.concat (List.cons (Num.box_byte (Num.to_char ||life /   1| % 10|)) List.nil) // life\\n      (List.concat (to_chars \\\" | \\\")\\n      (List.concat (List.cons (Num.box_byte (Num.to_char ||defs /  10| % 10|)) List.nil) //defs \\n      (List.concat (List.cons (Num.box_byte (Num.to_char ||defs /   1| % 10|)) List.nil) //defs \\n      (List.concat (to_chars \\\" | \\\")\\n      (List.concat (if side [(to_chars \\\"black \\\"),(to_chars \\\"white \\\")])\\n      (List.concat (if eff1 [(to_chars \\\"(eff1) \\\"), List.nil])\\n      (List.concat (if lock [(to_chars \\\"(lock) \\\"), List.nil])\\n      (List.concat (if mute [(to_chars \\\"(mute) \\\"), List.nil])\\n      (List.concat (if spec [(to_chars \\\"(spec) \\\"), List.nil])\\n              (List.cons #10 List.nil))))))))))))))\\n    (match_unit_kind unit case_void case_item case_goal case_hero)\\n\\n  dup is_enemy = # {unit_a unit_b} (is_enemy_side (get_unit_side unit_a) (get_unit_side unit_b))\\n  dup is_ally  = # {unit_a unit_b} (is_ally_side  (get_unit_side unit_a) (get_unit_side unit_b))\\n\\n  // Adds an amount of life to an unit\\n  dup heal = # {add_life unit}\\n    cpy unit      = unit\\n    let case_void = unit\\n    let case_item = unit\\n    let case_goal = unit\\n    let case_hero =\\n      cpy add_life = add_life\\n      cpy has_life = (get_unit_life unit)\\n      cpy max_life = (get_hero_max_life (get_unit_hero unit))\\n      cpy new_life = |has_life + add_life|\\n      if |new_life > 2147483648| then: // damage > life\\n        Void\\n      else: if |new_life > max_life| then:\\n        (set_unit_life max_life unit)\\n      else:\\n        (set_unit_life new_life unit)\\n    (match_unit_kind unit case_void case_item case_goal case_hero)\\n    \\n  // Removes an amount of life of an unit\\n  dup dmge = # {dmg unit} (heal |0 - dmg| unit)\\n  dup mute = # {trn unit} (mut_unit_mute {mute}|mute + trn| unit)\\n  dup lock = # {trn unit} (mut_unit_lock {lock}|lock + trn| unit)\\n  dup defs = # {def unit} (mut_unit_defs {defs}|defs + def| unit)\\n\\n  dup if_unit = # {comp fun caster target}\\n    cpy caster = caster\\n    cpy target = target\\n    if (comp caster target)\\n    then: (fun caster target)\\n    else: [caster, target]\\n\\n  dup dmge_enemy = # {val} (if_unit is_enemy {caster target}\\n    // Gets caster and target\\n    cpy c_old  = caster\\n    cpy t_old  = target\\n\\n    // Gets hero and spec info\\n    cpy c_hero = (get_unit_hero c_old)\\n    cpy t_hero = (get_unit_hero t_old)\\n    cpy t_spec = (get_unit_spec t_old)\\n\\n    // Applies armor\\n    cpy dmg    = val\\n    cpy def    = (get_unit_defs t_old)\\n    cpy t_defs = if |def > dmg| [|def - dmg|, 0]\\n    cpy dmg    = if |def > dmg| [0, |dmg - def|]\\n\\n    // Applies DODGE\\n    cpy dmg    =\\n      if ||t_hero == KENLUA| & |t_spec == |c_hero + 128|||\\n      then: 0\\n      else: dmg\\n\\n    // Applies damage\\n    cpy t_new  = (dmge dmg (set_unit_defs t_defs t_old))\\n\\n    // Applies SHADOW_BOND\\n    cpy c_new  =\\n      if |||t_hero == CRONI| & |t_new == Void|| & |t_spec > 0||\\n      then: Void\\n      else: c_old\\n\\n    [c_new, t_new])\\n\\n  dup lock_enemy = # {val} (if_unit is_enemy {caster target} [caster, (lock val target)])\\n  dup mute_enemy = # {val} (if_unit is_enemy {caster target} [caster, (mute val target)])\\n  dup heal_ally  = # {val} (if_unit is_ally  {caster target} [caster, (heal val target)])\\n  dup defs_ally  = # {val} (if_unit is_ally  {caster target} [caster, (defs val target)])\\n\\n  // \\\"a\\\" and \\\"b\\\" are side positions. The function checks if they can swap their position, that is, simulate a walk, and returns:\\n  // - The same position: if they can't interact with each other.\\n  // - Inverted position: the elements interacted and one now occupies the position of the other.\\n  dup a_step_to_b = # {a b}\\n    cpy a             = a\\n    cpy b             = b\\n    let case_a_void   = [a, b]\\n    let case_a_item   = [a, b]\\n    let case_a_goal   = [a, b]\\n    let case_a_hero   =\\n      let case_b_void = [b, a]\\n      let case_b_item =\\n        // TODO: don't activate trap if it is from the same team (must add that info on the trap)\\n        if |(get_unit_type b) == TRAP|\\n          then: [Void, (lock 2 a)]\\n          else: [a, b]\\n      let case_b_goal = [a, b]\\n      let case_b_hero = \\n        cpy a_side    = (get_unit_side a)\\n        cpy b_side    = (get_unit_side b)\\n        if |a_side == b_side|\\n          then: [b, a]\\n          else: [a, b]\\n      (match_unit_kind b case_b_void case_b_item case_b_goal case_b_hero)\\n    (match_unit_kind a case_a_void case_a_item case_a_goal case_a_hero)\\n\\n  // :::::::::::\\n  // :: Board ::\\n  // :::::::::::\\n\\ndup new_board = #\\n    //let O   = Void\\n    //let W   = (Item WALL)\\n    //let a   = (Hero WHITE GONK)\\n    //let b   = (Hero WHITE ERKOS)\\n    //let c   = (Hero WHITE KENLUA)\\n    //let d   = (Hero WHITE MEWEM)\\n    //let x   = (Goal WHITE)\\n    //let e   = (Hero BLACK TOPHORO)\\n    //let f   = (Hero BLACK CRONI)\\n    //let g   = (Hero BLACK FLINA)\\n    //let h   = (Hero BLACK STANCI)\\n    //let y   = (Goal BLACK)\\n    //let r00 = [[[[W,W],[W,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[h,W],[W,W]]]]\\n    //let r01 = [[[[W,W],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,g],[y,W]]]]\\n    //let r02 = [[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[f,W]]]]\\n    //let r03 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,e]]]]\\n    //let r04 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r05 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r06 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r07 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r08 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r09 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r10 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r11 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r12 = [[[[a,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    //let r13 = [[[[W,b],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]\\n    //let r14 = [[[[W,x],[c,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[W,W]]]]\\n    //let r15 = [[[[W,W],[W,d]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,W],[W,W]]]]\\n    //[[[[r00,r01],[r02,r03]],[[r04,r05],[r06,r07]]],[[[r08,r09],[r10,r11]],[[r12,r13],[r14,r15]]]]\\n\\n    let O   = Void\\n    let W   = (Item WALL)\\n    let a   = (Hero WHITE GONK)\\n    let b   = (Hero WHITE STANCI)\\n    let c   = (Hero WHITE ERKOS)\\n    let d   = (Hero WHITE KENLUA)\\n    let x   = (Goal WHITE)\\n    let e   = (Hero BLACK TOPHORO)\\n    let f   = (Hero BLACK CRONI)\\n    let g   = (Hero BLACK SNARCH)\\n    let h   = (Hero BLACK MEWEM)\\n    let y   = (Goal BLACK)\\n    let r00 = [[[[W,W],[W,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[h,W],[W,W]]]]\\n    let r01 = [[[[W,W],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,g],[y,W]]]]\\n    let r02 = [[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[f,W]]]]\\n    let r03 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,e]]]]\\n    let r04 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r05 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r06 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r07 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r08 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r09 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r10 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r11 = [[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r12 = [[[[a,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]\\n    let r13 = [[[[W,b],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]\\n    let r14 = [[[[W,x],[c,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[W,W]]]]\\n    let r15 = [[[[W,W],[W,d]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,W],[W,W]]]]\\n    [[[[r00,r01],[r02,r03]],[[r04,r05],[r06,r07]]],[[[r08,r09],[r10,r11]],[[r12,r13],[r14,r15]]]]\\n\\n  // Converts a 16x16 position to an index up to 256.\\n  dup board_index = # {pos}\\n    get [x,y] = pos\\n    cpy x     = x\\n    cpy y     = y\\n    cpy o     = ||x > 15| | |y > 15||\\n    let x     = if o [0, x]\\n    let y     = if o [0, y]\\n    ||y * 16| + x|\\n\\n  // Converts an index up to 256 to a 16x16 position.\\n  dup board_position = # {idx}\\n    cpy idx = idx\\n    [|idx % 16|, |idx / 16|]\\n\\n  dup board_interact = # {a_pos b_pos}\\n    cpy a_idx = (board_index a_pos)\\n    cpy b_idx = (board_index b_pos)\\n    if |a_idx == b_idx|\\n      then: {fun board}\\n        get [board,b_val] = (take8 b_idx Void board)\\n        cpy b_val         = b_val\\n        get [a_val,b_val] = (fun b_val b_val)\\n        let board         = (write8 b_idx b_val board)\\n        board\\n      else: {fun board}\\n        get [board,a_val] = (take8 a_idx Void board)\\n        get [board,b_val] = (take8 b_idx Void board)\\n        get [a_val,b_val] = (fun a_val b_val)\\n        let board         = (write8 a_idx a_val board)\\n        let board         = (write8 b_idx b_val board)\\n        board \\n\\n  dup board_swap = # {a_pos b_pos board}\\n    (board_interact a_pos b_pos {a b}[b,a] board)\\n\\n  // Apply a function to a board unit\\n  dup board_update = # {pos fun board}\\n    (update8 (board_index pos) fun board)\\n\\n  dup print_board = \\n    let NEWLINE = 10\\n    let SPACE   = 32\\n    let break_lines = {list Cons}\\n      dup Cons = Cons\\n      dup fold = (list #{x xs i}\\n        cpy i = i\\n        (if |i == 0| then:\\n          {list} (Cons NEWLINE list)\\n        else: if ||i % 32| == 0| then:\\n          {list} (Cons SPACE (Cons (Num.to_char ||i - 1| / 32|) (Cons NEWLINE list)))\\n        else:\\n          {list} list\\n        (Cons x (xs |i + 1|))))\\n      # {Nil} (fold {i}(Cons SPACE (Cons (Num.to_char 15) Nil)) 0)\\n    let fold_node = {lft rgt}\\n      get [lft_info, lft_board] = lft\\n      get [rgt_info, rgt_board] = rgt\\n      [(List.concat lft_info rgt_info), (List.concat lft_board rgt_board)]\\n    let fold_leaf = {unit}\\n      cpy unit = unit\\n      [(get_unit_info unit), (get_unit_icon unit)]\\n    dup fold = (fold8 #fold_node #fold_leaf)\\n    # {board}\\n      get [info_text, board_text] = (fold board)\\n      (from_chars\\n        (List.concat (List.cons NEWLINE List.nil)\\n        (List.concat (to_chars \\\" 0 1 2 3 4 5 6 7 8 9 a b c d e f\\\")\\n        (List.concat (break_lines board_text)\\n        (List.concat (List.cons NEWLINE List.nil)\\n        (List.concat (to_chars \\\"HR | HP | DF |\\\")\\n        (List.concat (List.cons NEWLINE List.nil)\\n        (List.concat (to_chars \\\"-- | -- | -- |\\\")\\n        (List.concat (List.cons NEWLINE List.nil)\\n        (List.concat info_text\\n          (List.cons NEWLINE List.nil)))))))))))\\n\\n  // get_hero_position\\n  // | Returns the position of a hero on the board, if any\\n  // | TODO: board should remember hero positions to avoid searching\\n  // : {hero : HeroID} ->\\n  //   {board : (Array ~8 Unitt)} ->\\n  //   [(Array ~8 Unit), (Maybe [Num,Num])]\\n  dup get_hero_position =\\n    let fold_node = {lft rgt her idx}\\n      cpy idx                  = idx\\n      cpy her                  = her\\n      get [lft_board, lft_pos] = (lft her |idx * 2|)\\n      get [rgt_board, rgt_pos] = (rgt her ||idx * 2| + 1|)\\n      [[lft_board, rgt_board], (maybe_concat lft_pos rgt_pos)]\\n    let fold_leaf = {unit her idx}\\n      cpy unit = unit\\n      if ||(get_unit_kind unit) == HERO| & |(get_unit_hero unit) == her||\\n        then: [unit, (Just (board_position idx))]\\n        else: [unit, None]\\n    dup find = (fold8 #fold_node #fold_leaf)\\n    # {hero board}\\n      (find board hero 0)\\n\\n  dup query_at = # {pos func board}\\n    let cpy_app_func = {unit}\\n      cpy unit = unit\\n      [unit, (func unit)]\\n    (with8 (board_index pos) cpy_app_func board)\\n\\n  dup get_at = # {pos board}\\n    (query_at pos {x}x board)\\n\\n  dup is_void_at  = # {pos board} (query_at pos {unit}|(get_unit_kind unit) == VOID| board)\\n  dup is_item_at  = # {pos board} (query_at pos {unit}|(get_unit_kind unit) == WALL| board)\\n  dup is_goal_at  = # {pos board} (query_at pos {unit}|(get_unit_kind unit) == GOAL| board)\\n  dup is_hero_at  = # {pos hero board} (query_at pos ({unit} cpy unit = unit ||(get_unit_kind unit) == HERO| & |(get_unit_hero unit) == hero||) board)\\n  dup get_lock_at = # {pos board} (query_at pos get_unit_lock board)\\n  dup get_mute_at = # {pos board} (query_at pos get_unit_mute board)\\n  dup get_side_at = # {pos board} (query_at pos get_unit_side board)\\n  dup get_life_at = # {pos board} (query_at pos get_unit_life board)\\n  dup get_defs_at = # {pos board} (query_at pos get_unit_defs board)\\n  dup comp_side = # {comp a_pos b_pos board}\\n    get [board, a_side] = (get_side_at a_pos board)\\n    get [board, b_side] = (get_side_at b_pos board)\\n    [board, (comp a_side b_side)]\\n  dup are_enemies_at = # (comp_side {a b}|a == b|)\\n  dup are_allies_at = # (comp_side {a b}|a == b|)\\n\\n  // :::::::::::::\\n  // :: Effects ::\\n  // :::::::::::::\\n\\n  // Given a position and a direction to step forward, move the element (if is possible) and return the updated map\\n  dup step = # {a_pos a_dxy board}\\n    get [a_pos0,a_pos1] = (V2.cpy a_pos)\\n    let b_pos           = (V2.add a_pos0 a_dxy)\\n    (board_interact a_pos1 b_pos a_step_to_b board)\\n\\n  // cast_area\\n  // : {-P    : Type}\\n  //   {range : Num}\\n  //   {area  : Area}\\n  //   {hits  : {cpos : [Num,Num]} {hpos : [Num,Num]} {state : P} P}\\n  // ! {pos   : [Num,Num]}\\n  //   {dirs  : (SList [Num,Num])}\\n  //   {state : P}\\n  //   P\\n  let cast_area = {range area hits}\\n    dup range = range\\n    dup hits  = hits\\n    dup exec  = (area #{hpos state}\\n      get [state, cpos]  = state\\n      get [cpos0, cpos1] = (V2.cpy cpos)\\n      get [hpos0, hpos1] = (V2.cpy hpos)\\n      let new_state      = (hits cpos0 hpos0 state)\\n      [new_state, cpos1])\\n    # {cpos tpos}\\n      get [cpos0, cpos1] = (V2.cpy cpos)\\n      get [tpos0, tpos1] = (V2.cpy tpos)\\n      if |(V2.flat_dist cpos0 tpos0) < |range + 1||\\n      then: {state} (fst (exec tpos1 [state, cpos1]))\\n      else: {state} state\\n\\n  // cast_wave\\n  // : {-P    : Type}\\n  //   {area  : Area}\\n  //   {hits  : {cpos : [Num,Num]} {tpos : [Num,Num]} {dir : [Num,Num]} {state : P} P}\\n  // ! {pos   : [Num,Num]}\\n  //   {dir   : [Num,Num]}\\n  //   {state : P}\\n  //   P\\n  let cast_wave = {area hits}\\n    dup hits = hits\\n    dup exec = (area #{hpos_dir state}\\n      get [hpos, dir]    = hpos_dir\\n      get [state, cpos]  = state\\n      get [cpos0, cpos1] = (V2.cpy cpos)\\n      get [hpos0, hpos1] = (V2.cpy hpos)\\n      let new_state      = (hits cpos0 hpos0 dir state)\\n      [new_state, cpos1])\\n    # {pos dir state}\\n      get [cpos0, cpos1] = (V2.cpy pos)\\n      get [state, cpos]  = (exec cpos0 dir [state, cpos1])\\n      state\\n\\n  // Walks through a set of directions\\n  let walk = {range}\\n    let rang = range\\n    let area = V2.range_0\\n    let hits = {cpos tpos board}\\n      let effect = {caster target}\\n        cpy caster = caster\\n        cpy target = target\\n        cpy c_lock = (get_unit_lock caster)\\n        cpy c_hero = (get_unit_hero caster)\\n        cpy c_spec = (get_unit_spec caster)\\n        cpy locked = |c_lock | ||c_hero == SNARCH| & |c_spec > 0|||\\n        if locked\\n        then: [caster, target]\\n        else: (a_step_to_b caster target)\\n      (board_interact cpos tpos effect board)\\n    (cast_area rang area #hits)\\n\\n  // == Tophoro ==\\n  // ~~~~~~~~~~~~~\\n\\n  dup tophoro_walk = (walk #3)\\n\\n  dup earth_root = (cast_area #32 V2.range_0 # {cpos tpos board}\\n    (board_update cpos {unit}(heal 20 (mute 3 (lock 3 unit))) board))\\n\\n  dup earth_rise =\\n    let rang = #2\\n    let area = V2.range_1\\n    let hits = #{cpos tpos board} \\n      let effect = {caster target}\\n        get [caster, target] = (dmge_enemy 2 caster target)\\n        get [caster, target] = (mute_enemy 1 caster target)\\n        [caster, target]\\n      (board_interact cpos tpos effect board)\\n    (cast_area rang area hits)\\n\\n  dup earth_wall =\\n    let rang = #2\\n    let area = V2.range_1\\n    let wall = {unit}\\n      cpy unit = unit\\n      if |(get_unit_kind unit) == VOID|\\n      then: (Item ROCK)\\n      else: unit\\n    let hits = {cpos tpos board}\\n      (board_update tpos wall board)\\n    (cast_area #2 area #hits)\\n\\n  let test_earth_root = \\n    let board = new_board\\n    let board = (board_update [0xf,0x3] (dmge 50) board)\\n    let board = (earth_root [0xf,0x3] [0xf,0x3] board)\\n    (print_board board)\\n\\n  let test_earth_rise = \\n    let board = new_board\\n    let board = (board_swap [0x3,0xf] [0xf,0x5] board)\\n    let board = (earth_rise [0xf,0x3] [0xf,0x4] board)\\n    (print_board board)\\n\\n  let test_earth_wall =\\n    let board = new_board\\n    let board = (board_swap [0x3,0xf] [0xf,0x5] board)\\n    let board = (earth_wall [0xf,0x3] [0xe,0x4] board)\\n    (print_board board)\\n\\n  // == Gonk ==\\n  // ~~~~~~~~~~\\n\\n  dup gonk_walk = (walk #3)\\n\\n  dup empathy = \\n    let rang = #1\\n    let area = V2.range_1\\n    let hits = #{cpos tpos board} (board_interact cpos tpos (defs_ally 5) board)\\n    dup cast = (cast_area rang area hits)\\n    # {cpos tpos board}\\n      get [cpos0, cpos1] = (V2.cpy cpos)\\n      let board          = (cast cpos1 tpos board)\\n      let board          = (board_update cpos0 (dmge 2) board)\\n      board\\n\\n  dup revenge =\\n    let rang = #1\\n    let area = V2.range_0\\n    let hits = #{cpos tpos board}\\n      get [cpos0, cpos1] = (V2.cpy cpos)\\n      get [board, life]  = (get_life_at cpos0 board)\\n      let effect         = (dmge_enemy ||40 - life| / 4|)\\n      (board_interact cpos1 tpos effect board)\\n    (cast_area rang area hits)\\n\\n  dup ground_slam =\\n    let rang = #0\\n    let area = V2.range_2\\n    let hits = #{cpos tpos board}\\n      get [tpos0, tpos1] = (V2.cpy tpos)\\n      let effect         = {caster target}\\n        get [caster, target] = (dmge_enemy 2 caster target)\\n        get [caster, target] = (mute_enemy 1 caster target)\\n        [caster, target]\\n      (board_interact cpos tpos1 effect board)\\n    (cast_area rang area hits)\\n\\n  let test_empathy =\\n    let board = new_board\\n    let board = (gonk_walk [0x0,0xc] [0x2,0xc] board)\\n    let board = (board_swap [0xf,0x3] [0x5,0xe] board)\\n    let board = (empathy [0x2,0xc] [0x2,0xd] board)\\n    let board = (earth_rise [0x5,0xe] [0x3,0xe] board)\\n    let board = (earth_rise [0x5,0xe] [0x3,0xe] board)\\n    let board = (earth_rise [0x5,0xe] [0x3,0xe] board)\\n    (print_board board)\\n\\n  let test_revenge =\\n    let board = new_board\\n    let board = (board_swap [0x0,0xc] [0xf,0x4] board)\\n    let board = (board_update [0xf,0x4] (dmge 32) board)\\n    let board = (revenge [0xF,0x4] [0xF,0x3] board)\\n    (print_board board)\\n\\n  let test_ground_slam =\\n    let board = new_board\\n    let board = (board_swap [0x0,0xc] [0xe,0x3] board)\\n    let board = (ground_slam [0xe,0x3] [0xe,0x3] board)\\n    (print_board board)\\n\\n  // == Stanci ==\\n  // ~~~~~~~~~~~~\\n\\n  dup stanci_walk = (walk #3)\\n\\n  dup restore =\\n    let rang = #3\\n    let area = V2.range_0\\n    let hits = #{cpos hpos board} (board_interact cpos hpos (heal_ally 3) board)\\n    (cast_area rang area hits)\\n\\n  dup escort =\\n    let rang = #3\\n    let area = V2.range_0\\n    let hits = #{cpos hpos board} (board_interact cpos hpos (defs_ally 3) board)\\n    (cast_area rang area hits)\\n\\n  dup detain =\\n    let rang = #3\\n    let area = V2.range_0\\n    let hits = #{cpos hpos board} (board_interact cpos hpos (mute_enemy 1) board)\\n    (cast_area rang area hits)\\n\\n  let test_restore =\\n    let board = new_board\\n    let board = (board_update [0xe,0x2] (dmge 10) board)\\n    let board = (restore [0xd,0x1] [0xe,0x2] board)\\n    (print_board board)\\n\\n  let test_escort =\\n    let board = new_board\\n    let board = (escort [0xd,0x1] [0xe,0x2] board)\\n    (print_board board)\\n\\n  let test_detain =\\n    let board = new_board\\n    let board = (board_swap [0x0,0xc] [0xc,0x2] board)\\n    let board = (detain [0xd,0x1] [0xc,0x2] board)\\n    (print_board board)\\n\\n  // == Erkos ==\\n  // ~~~~~~~~~~~\\n\\n  dup erkos_walk = (walk #3)\\n\\n  dup flame_ball =\\n    let rang = #3\\n    let area = V2.range_2\\n    let hits = # {cpos hpos board} (board_interact cpos hpos (dmge_enemy 3) board)\\n    (cast_area rang area hits)\\n\\n  dup flame_wave =\\n    let rang = #3\\n    let area = V2.range_1\\n    let hits = # {cpos hpos board} (board_interact cpos hpos (dmge_enemy 5) board)\\n    (cast_area rang area hits)\\n\\n  dup flame_nova = \\n    let rang = #0\\n    let area = V2.range_6\\n    let hits = #{cpos hpos board} (board_interact cpos hpos (dmge_enemy 15) board)\\n    dup cast = (cast_area rang area hits)\\n    # {cpos tpos board}\\n      get [cpos0, cpos1] = (V2.cpy cpos)\\n      get [cpos2, cpos3] = (V2.cpy cpos0)\\n      let board          = (cast cpos2 cpos3 board)\\n      let board          = (board_update cpos1 (dmge 30) board)\\n      board\\n\\n  let test_flame_ball =\\n    let board = new_board\\n    let board = (board_swap [0x1,0xd] [0xd,0x5] board)\\n    let board = (flame_ball [0xd,0x5] [0xd,0x3] board)\\n    (print_board board)\\n\\n  let test_flame_wave =\\n    let board = new_board\\n    let board = (board_swap [0x1,0xd] [0xd,0x5] board)\\n    let board = (flame_wave [0xd,0x5] [0xd,0x2] board)\\n    (print_board board)\\n\\n  let test_flame_nova =\\n    let board = new_board\\n    let board = (board_swap [0x1,0xd] [0xd,0x5] board)\\n    let board = (flame_nova [0xd,0x5] 12 board)\\n    (print_board board)\\n\\n  // == Croni ==\\n  // ~~~~~~~~~~~\\n\\n  dup croni_walk = (walk #3)\\n\\n  dup shadow_bond = # {pos nil board}\\n    let bind = {unit}\\n      let unit = (dmge 3 unit)\\n      let unit = (set_unit_spec 1 unit)\\n      unit\\n    (board_update pos bind board)\\n\\n  dup shadow_trap = \\n    let rang = #6\\n    let area = V2.range_0\\n    let hits = #{cpos hpos board}\\n      let put_trap = {unit}\\n        cpy unit = unit\\n        if |(get_unit_kind unit) == VOID|\\n        then: (Item TRAP)\\n        else: unit\\n      (board_update hpos put_trap board)\\n    (cast_area rang area hits)\\n\\n  dup shadow_flux =\\n    let rang = #6\\n    let area = V2.range_1\\n    let hits = #{cpos tpos board} (board_interact cpos tpos (dmge_enemy 8) board)\\n    (cast_area rang area hits)\\n\\n  let test_shadow_trap =\\n    let board = new_board\\n    let board = (board_swap [0xe,0x2] [0xa,0xd] board)\\n    let board = (shadow_trap [0xa,0xd] [0x2,0xd] board)\\n    let board = (erkos_walk [0x1,0xd] [0x2,0xd] board)\\n    (print_board board)\\n\\n  let test_shadow_bond =\\n    let board = new_board\\n    let board = (shadow_bond [0xe,0x2] [0,0] board)\\n    let board = (board_swap [0x1,0xd] [0xe,0x3] board)\\n    let board = (board_update [0xe,0x2] (dmge 16) board)\\n    let board = (flame_wave [0xe,0x3] [0xe,0x2] board)\\n    (print_board board)\\n\\n  // == Snarch ==\\n  // ~~~~~~~~~~~~\\n\\n  dup snarch_walk = (walk #3)\\n\\n  dup ballista = # {pos nil board}\\n    let mount = {unit}\\n      cpy unit = unit\\n      let spec = (get_unit_spec unit)\\n      let unit = (mut_unit_lock {x}|x + 1| unit)\\n      let unit = (mut_unit_mute {x}|x + 1| unit)\\n      let unit = (set_unit_spec |1 - spec| unit)\\n      unit\\n    (board_update pos mount board)\\n\\n  dup quick_bolt_0 =\\n    let area = V2.range_1\\n    let hits = #{cpos hpos} (board_interact cpos hpos (dmge_enemy 2))\\n    let rngX = {rng} (cast_area rng area hits)\\n    dup rngA = (rngX #6)\\n    dup rngB = (rngX #12)\\n    # {cpos hpos board}\\n      get [cpos0, cpos1]   = (V2.cpy cpos)\\n      get [board, mounted] = (query_at cpos0 get_unit_spec board) \\n      (if mounted [rngB, rngA] cpos1 hpos board)\\n\\n  dup quick_bolt_1 = # quick_bolt_0\\n\\n  let test_quick_bolt_0 =\\n    let board = new_board\\n    let board = (write8 (board_index [0xd,0x4]) (Hero BLACK SNARCH) board)\\n    let board = (quick_bolt_0 [0xd,0x4] [0xd,0x1] board)\\n    (print_board board)\\n\\n  let test_ballista =\\n    let board = new_board\\n    let board = (write8 (board_index [0xd,0xd]) (Hero WHITE SNARCH) board)\\n    let board = (ballista [0xd,0xd] 0 board)\\n    let board = (board_update [0xd,0xd] (set_unit_lock 0) board)\\n    let board = (board_update [0xd,0xd] (set_unit_mute 0) board)\\n    let board = (quick_bolt_0 [0xd,0xd] [0xd,0x1] board)\\n    let board = (snarch_walk [0xd,0xd] [0xd,0xe] board)\\n    (print_board board)\\n\\n  // == Sirpix ==\\n  // ~~~~~~~~~~~~\\n\\n  dup sirpix_walk = (walk #3)\\n\\n  dup stealth_move = # {cpos tpos board}\\n    get [cx, cy]      = cpos\\n    get [tx, ty]      = tpos\\n    cpy cx            = cx\\n    cpy cy            = cy\\n    cpy tx            = tx\\n    cpy ty            = ty\\n    get [board, spec] = (query_at [cx,cy] get_unit_spec board)\\n    cpy spec          = spec\\n    cpy spec          = if |spec == 0| [||cy << 4| | cx|, spec]\\n    cpy sx            = ||spec >> 0| & 0b1111|\\n    cpy sy            = ||spec >> 4| & 0b1111|\\n    (if |(V2.flat_dist [sx,sy] [tx,ty]) < |4 + 1||\\n      then: {board} (board_update [cx,cy] (set_unit_spec ||ty << 4| | tx|) board)\\n      else: {board} board\\n      board)\\n\\n    dup stealth_strike =\\n      let rang = #0\\n      let area = V2.range_1\\n      let hits = {cpos hpos} (board_interact cpos hpos (dmge_enemy 3))\\n      let cast = (cast_area rang area hits)\\n      # {cpos nil board}\\n          get [cx, cy]      = cpos\\n          cpy cx            = cx\\n          cpy cy            = cy\\n          get [board, spec] = (query_at [cx,cy] get_unit_spec board)\\n          cpy spec          = spec\\n          cpy spec          = if |spec == 0| [||cy << 4| | cx|, spec]\\n          cpy sx            = ||spec >> 0| & 0b1111|\\n          cpy sy            = ||spec >> 4| & 0b1111|\\n          get [board, void] = (is_void_at [sx,sy] board)\\n          (if void\\n            then: {board}\\n              let board = (board_update [cx,cy] (set_unit_spec ||cy << 4| | cx|) board)\\n              let board = (board_swap [cx,cy] [sx,sy] board)\\n              let board = (cast [sx,sy] [sx,sy] board)\\n              board\\n            else: {board}\\n              board\\n            board)\\n\\n  dup lockpick = # {cpos nil board}\\n    board\\n\\n  let test_stealth =\\n    let board = new_board\\n    let board = (write8 (board_index [0xd,0xd]) (Hero BLACK SIRPIX) board)\\n    let board = (stealth_move [0xd,0xd] [0xd,0x9] board)\\n    let board = (stealth_move [0xd,0xd] [0xd,0x5] board)\\n    let board = (stealth_move [0xd,0xd] [0xd,0x2] board)\\n    let board = (stealth_strike [0xd,0xd] 0 board)\\n    (print_board board)\\n\\n  // == Kenlua ==\\n  // ~~~~~~~~~~~~\\n\\n  dup kenlua_walk = (walk #3)\\n\\n  dup haste =\\n    let rang = #0\\n    let area = V2.range_1\\n    let hits = # {cpos tpos} (board_interact cpos tpos (dmge_enemy 4))\\n    dup strike = (cast_area rang area hits)\\n    # {cpos tpos board}\\n      get [cpos0, cpos1] = (V2.cpy cpos)\\n      get [tposA, tposB] = (V2.cpy tpos)\\n      get [tpos0, tpos1] = (V2.cpy tposA)\\n      get [tpos2, tpos3] = (V2.cpy tposB)\\n      get [board, void]  = (is_void_at tpos0 board)\\n      (if void\\n        then: {board}\\n          let board = (board_update cpos0 (dmge 1) board)\\n          let board = (board_swap cpos1 tpos1 board)\\n          let board = (strike tpos2 tpos3 board)\\n          board\\n        else: {board}\\n          board\\n        board)\\n\\n  dup dodge =\\n    let rang = #32\\n    let area = V2.range_0\\n    let hits = #{cpos tpos board}\\n      let effect = {caster target}\\n        cpy caster = caster\\n        cpy target = target\\n        let caster = if |(get_unit_kind target) == HERO|\\n          then: (set_unit_spec |(get_unit_hero target) + 128| caster)\\n          else: caster\\n        [caster, target]\\n      (board_interact cpos tpos effect board)\\n    (cast_area rang area hits)\\n\\n  dup slash =\\n    let rang = #1\\n    let area = V2.range_0\\n    let hits = # {cpos tpos} (board_interact cpos tpos (dmge_enemy 16))\\n    (cast_area rang area hits)\\n\\n  let test_haste =\\n    let board = new_board\\n    let board = (write8 (board_index [0xd,0x8]) (Hero WHITE KENLUA) board)\\n    let board = (kenlua_walk [0xd,0x8] [0xd,0x5] board)\\n    let board = (haste [0xd,0x5] [0xd,0x2] board)\\n    (print_board board)\\n\\n  let test_dodge =\\n    let board = new_board\\n    let board = (board_swap [0xf,0x3] [0x4,0xe] board)\\n    let board = (board_swap [0xe,0x2] [0x6,0xe] board)\\n    let board = (dodge [0x2,0xe] [0x4,0xe] board)\\n    let board = (earth_rise [0x4,0xe] [0x2,0xe] board)\\n    let board = (shadow_flux [0x6,0xe] [0x2,0xe] board)\\n    (print_board board)\\n\\n  let test_slash =\\n    let board = new_board\\n    let board = (write8 (board_index [0xe,0x3]) (Hero WHITE KENLUA) board)\\n    let board = (board_update [0xe,0x3] (dmge 20) board)\\n    let board = (slash [0xe,0x3] [0xf,0x3] board)\\n    (print_board board)\\n\\n  // == Flina ==\\n  // ~~~~~~~~~~~\\n\\n  dup flina_walk = (walk #3)\\n\\n  dup javelin =\\n    let rang = #2\\n    let area = V2.range_0\\n    let hits = {cpos tpos} (board_interact cpos tpos (dmge_enemy 4))\\n    (cast_area rang area #hits)\\n\\n  dup fly =\\n    let rang = #3\\n    let area = V2.range_0\\n    let hits = {cpos tpos} (board_interact cpos tpos a_step_to_b)\\n    (cast_area rang area #hits)\\n\\n  dup gust =\\n    let rang = #2\\n    let area = V2.range_1\\n    let hits = # {cpos hpos board} (board_interact cpos hpos (dmge_enemy 3) board)\\n    (cast_area rang area hits)\\n\\n  let test_javelin =\\n    let board = new_board\\n    let board = (board_swap [0x1,0xd] [0xa,0x0] board)\\n    let board = (javelin [0xc,0x0] [0xa,0x0] board)\\n    (print_board board)\\n\\n  let test_fly =\\n    let board = new_board\\n    let board = (board_swap [0x0,0xc] [0xa,0x2] board)\\n    let board = (fly [0xc,0x0] [0xa,0x2] board)\\n    (print_board board)\\n\\n  // == Zagatur ==\\n  // ~~~~~~~~~~~~~\\n\\n  dup zagatur_walk = (walk #0)\\n\\n  dup wrap =\\n    let rang = #0\\n    let area = V2.range_1\\n    let hits = #{cpos tpos board} (board_interact cpos tpos (lock_enemy 1) board)\\n    (cast_area rang area hits)\\n\\n  dup needle =\\n    let rang = #0\\n    let area = V2.range_1\\n    let hits = # {cpos tpos board} (board_interact cpos tpos (dmge_enemy 3) board)\\n    (cast_area rang area hits)\\n\\n  dup summon =\\n    let rang = #4\\n    let area = V2.range_0\\n    let hits = {cpos tpos board}\\n      let effect = {caster target}\\n        cpy caster = caster\\n        cpy target = target\\n        let target = if |(get_unit_kind target) == VOID|\\n          then: (Hero (get_unit_side caster) ZAGATUR)\\n          else: target\\n        [caster, target]\\n      (board_interact cpos tpos effect board)\\n    (cast_area #2 V2.range_0 #hits)\\n\\n  let test_summon =\\n    let board = new_board\\n    let board = (write8 (board_index [0x3,0xe]) (Hero BLACK ZAGATUR) board)\\n    let board = (summon [0x3,0xe] [0x5,0xe] board)\\n    let board = (needle [0x3,0xe] [0x3,0xe] board)\\n    let board = (wrap [0x3,0xe] [0x3,0xe] board)\\n    (print_board board)\\n\\n  // == Agdris ==\\n  // ~~~~~~~~~~~~\\n\\n  dup agdris_walk = (walk #1)\\n\\n  dup silence =\\n    let rang = #32\\n    let area = V2.range_0\\n    let hits = {cpos tpos} (board_interact cpos tpos (mute_enemy 1))\\n    (cast_area rang area #hits)\\n\\n  dup protect =\\n    let rang = #32\\n    let area = V2.range_0\\n    let hits = {cpos tpos} (board_interact cpos tpos (defs_ally 3))\\n    (cast_area rang area #hits)\\n\\n  dup memento =\\n    let rang = #32\\n    let area = V2.range_2\\n    let hit0 = # {cpos tpos} (board_interact cpos tpos (mute_enemy 1))\\n    let hit1 = # {cpos tpos} (board_interact cpos tpos (lock_enemy 1))\\n    let hit2 = # {cpos tpos} (board_interact cpos tpos (dmge_enemy 2))\\n    let hit3 = # {cpos tpos} (board_interact cpos tpos (defs_ally 2))\\n    let hit4 = # {cpos tpos} (board_interact cpos tpos (heal_ally 2))\\n    dup eff0 = (cast_area rang area hit0)\\n    dup eff1 = (cast_area rang area hit1)\\n    dup eff2 = (cast_area rang area hit2)\\n    dup eff3 = (cast_area rang area hit3)\\n    dup eff4 = (cast_area rang area hit4)\\n    # {cpos tpos board}\\n      get [cx, cy] = cpos\\n      get [tx, ty] = tpos\\n      cpy cx       = cx\\n      cpy cy       = cy\\n      cpy tx       = tx\\n      cpy ty       = ty\\n      let board    = (eff0 [cx,cy] [tx,ty] board)\\n      let board    = (eff1 [cx,cy] [tx,ty] board)\\n      let board    = (eff2 [cx,cy] [tx,ty] board)\\n      let board    = (eff3 [cx,cy] [tx,ty] board)\\n      let board    = (eff4 [cx,cy] [tx,ty] board)\\n      let board    = (board_update [cx,cy] (dmge 63) board)\\n      board\\n\\n  let test_silence =\\n    let board = new_board\\n    let board = (write8 (board_index [0x2,0xd]) (Hero WHITE AGDRIS) board)\\n    let board = (silence [0x2,0xd] [0xc,0x0] board)\\n    (print_board board)\\n\\n  let test_protect =\\n    let board = new_board\\n    let board = (write8 (board_index [0x2,0xd]) (Hero WHITE AGDRIS) board)\\n    let board = (protect [0x2,0xd] [0x0,0xc] board)\\n    (print_board board)\\n\\n  let test_memento =\\n    let board = new_board\\n    let board = (write8 (board_index [0x2,0xd]) (Hero WHITE AGDRIS) board)\\n    let board = (board_swap [0xe,0x2] [0x3,0xd] board)\\n    let board = (board_swap [0xd,0x1] [0x2,0xc] board)\\n    let board = (memento [0x2,0xd] [0x2,0xd] board)\\n    (print_board board)\\n\\n  // == Mewem ==\\n  // ~~~~~~~~~~~\\n\\n  dup mewem_walk = (walk #0)\\n\\n  dup teleport =\\n    let rang = #32\\n    let area = V2.range_0\\n    let hits = {cpos tpos} (board_interact cpos tpos a_step_to_b)\\n    (cast_area rang area #hits)\\n\\n  dup psychock =\\n    let rang = #4\\n    let area = V2.range_1\\n    let hits = #{cpos tpos board} (board_interact cpos tpos (dmge_enemy 6) board)\\n    (cast_area rang area hits)\\n\\n  dup imprison =\\n    let rang = #4\\n    let area = V2.range_1\\n    let hits = #{cpos tpos board} (board_interact cpos tpos (lock_enemy 2) board)\\n    (cast_area rang area hits)\\n\\n  // == That's all! ==\\n  // ~~~~~~~~~~~~~~~~~\\n\\n  dup get_skill_effect = # {skill}\\n    let to = [[tophoro_walk , earth_root]   , [earth_wall     , earth_rise]]\\n    let go = [[gonk_walk    , empathy]      , [revenge        , ground_slam]]\\n    let st = [[stanci_walk  , restore]      , [escort         , detain]]\\n    let h3 = 0\\n    let er = [[erkos_walk   , flame_ball]   , [flame_wave     , flame_nova]]\\n    let cr = [[croni_walk   , shadow_bond]  , [shadow_trap    , shadow_flux]]\\n    let sn = [[snarch_walk  , ballista]     , [quick_bolt_0   , quick_bolt_1]]\\n    let h7 = 0\\n    let si = [[sirpix_walk  , stealth_move] , [stealth_strike , lockpick]]\\n    let ke = [[kenlua_walk  , haste]        , [dodge          , slash]]\\n    let fl = [[flina_walk   , javelin]      , [fly            , gust]]\\n    let hB = 0\\n    let za = [[zagatur_walk , needle]       , [wrap           , summon]]\\n    let ag = [[agdris_walk  , protect]      , [silence        , memento]]\\n    let me = [[mewem_walk   , teleport]     , [psychock       , imprison]]\\n    let hF = 0\\n    let r0 = [[[to,go],[st,h3]],[[er,cr],[sn,h7]]]\\n    let r1 = [[[si,ke],[fl,hB]],[[za,ag],[me,hF]]]\\n    (snd (take6 skill 0 [r0, r1]))\\n\\n  // :::::::::::\\n  // :: Casts ::\\n  // :::::::::::\\n\\n  // empty_cast\\n  dup empty_cast = # Stack.new\\n\\n  let sort_casts = {casts} {Cons}\\n   dup Cons = Cons\\n   dup arr = (init6 #{Nil} Nil)\\n   let loop = {cast arr}\\n     get [id, name] = cast\\n     cpy id = id\\n     let priority = (get_skill_priority id)\\n     let append = {cont} {k} (Cons [id, name] (cont k))\\n     (update6 priority append arr)\\n   dup rec = (casts #loop)\\n   dup arr = # (rec arr)\\n   dup fold = (fold6 #{arr1 arr2} {Nil} (arr1 (arr2 Nil)) #{x} x)\\n   #(fold arr)\\n\\n  let cast = {cast board}\\n    get [skill, argm]  = cast\\n    cpy skill          = skill\\n    let hero           = |skill / 4|\\n    get [board, cpos]  = (get_hero_position hero board) \\n    let case_cpos_none = {board}\\n      board\\n    let case_cpos_just = {cpos} {board}\\n      get [cpos0, cpos1] = (V2.cpy cpos)\\n      get [board, unit]  = (get_at cpos0 board)\\n      let is_muted       = (get_unit_mute unit)\\n      (if is_muted\\n        then: {cpos board} board\\n        else: {cpos board}\\n          let effect = (get_skill_effect skill)\\n          let board  = (effect cpos argm board)\\n          board\\n      cpos1 board)\\n    (cpos case_cpos_none case_cpos_just board)\\n\\n  let test_muted_cast =\\n      let board = new_board\\n      let board = (write8 (board_index [0x2,0xd]) (Hero WHITE AGDRIS) board)\\n      let board = (cast [SILENCE,[0xc,0x0]] board)\\n      let board = (board_update [0xd,0x1] (dmge 8) board)\\n      let board = (cast [RESTORE,[0xd,0x1]] board)\\n      (print_board board)\\n\\n  // TODO: create end_turn function\\n  dup end_turn = \\n    let fold_node = {lft rgt}\\n      [lft, rgt]\\n    let fold_leaf = {unit}\\n      cpy unit = unit\\n      let case_void =\\n        unit\\n      let case_item =\\n        cpy item = (get_unit_type unit)\\n        if |item == ROCK| then:\\n          Void\\n        else: if |item == TRAP| then:\\n          Void\\n        else:\\n          unit\\n      let case_goal =\\n        unit\\n      let case_hero =\\n        cpy lock = (get_unit_lock unit)\\n        cpy mute = (get_unit_mute unit)\\n        cpy hero = (get_unit_hero unit)\\n        cpy spec = (get_unit_spec unit)\\n        let lock = if |lock > 0| [|lock - 1|, lock]\\n        let mute = if |mute > 0| [|mute - 1|, mute]\\n        let defs = 0\\n        let spec = if ||hero == KENLUA| & |spec > 0|| [0, spec] // remove DODGE\\n        let spec = if ||hero == CRONI| & |spec > 0|| [0, spec] // remove SHADOW_BOND\\n        let unit = (set_unit_lock lock unit)\\n        let unit = (set_unit_mute mute unit)\\n        let unit = (set_unit_defs defs unit)\\n        let unit = (set_unit_spec spec unit)\\n        unit\\n      (match_unit_kind unit case_void case_item case_goal case_hero)\\n    (fold8 #fold_node #fold_leaf)\\n\\n  let test_end_turn =\\n    let board = new_board\\n    let board = (cast [EARTH_WALL,[0xf,0x4]] board)\\n    let board = (cast [SHADOW_BOND,[0xe,0x2]] board)\\n    let board = (board_update [0x0,0xc] (lock 1) board)\\n    //let board = (end_turn board)\\n    (print_board board)\\n\\n  dup exports =\\n    [#new_board,\\n    [#cast,\\n    [#print_board,\\n    [#unit_to_scott,\\n    [#get_skill_priority,\\n    [#get_skill_area,\\n    [#get_at,\\n    [#end_turn,\\n    [#TOPHORO,\\n    [#GONK,\\n    [#STANCI,\\n    [#HERO_3,\\n    [#ERKOS,\\n    [#CRONI,\\n    [#SNARCH,\\n    [#HERO_7,\\n    [#SIRPIX,\\n    [#KENLUA,\\n    [#FLINA,\\n    [#HERO_B,\\n    [#ZAGATUR,\\n    [#AGDRIS,\\n    [#MEWEM,\\n    [#HERO_F,\\n     0]]]]]]]]]]]]]]]]]]]]]]]]\\n\\n  # exports\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/kaelin.fmc?");

/***/ }),

/***/ "../formality/stdlib/keccak.fmc":
/*!**************************************!*\
  !*** ../formality/stdlib/keccak.fmc ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Keccak hash function\\n\\n// Computes the Keccak256 of \\\"random hash\\\"\\ndef Keccak.ex:\\n  (Keccak.bytes_to_hex (Keccak.256 (to_chars \\\"random hash\\\")))\\n\\ndef Keccak.f_loop: {arr} {t}\\n  (arr {n\\n    a00 a01 a02 a03 a04 a05 a06 a07 a08 a09\\n    a10 a11 a12 a13 a14 a15 a16 a17 a18 a19\\n    a20 a21 a22 a23 a24 a25 a26 a27 a28 a29\\n    a30 a31 a32 a33 a34 a35 a36 a37 a38 a39\\n    a40 a41 a42 a43 a44 a45 a46 a47 a48 a49}\\n\\n    dup n   = n\\n    dup a00 = a00\\n    dup a01 = a01\\n    dup a02 = a02\\n    dup a03 = a03\\n    dup a04 = a04\\n    dup a05 = a05\\n    dup a06 = a06\\n    dup a07 = a07\\n    dup a08 = a08\\n    dup a09 = a09\\n    dup a10 = a10\\n    dup a11 = a11\\n    dup a12 = a12\\n    dup a13 = a13\\n    dup a14 = a14\\n    dup a15 = a15\\n    dup a16 = a16\\n    dup a17 = a17\\n    dup a18 = a18\\n    dup a19 = a19\\n    dup a20 = a20\\n    dup a21 = a21\\n    dup a22 = a22\\n    dup a23 = a23\\n    dup a24 = a24\\n    dup a25 = a25\\n    dup a26 = a26\\n    dup a27 = a27\\n    dup a28 = a28\\n    dup a29 = a29\\n    dup a30 = a30\\n    dup a31 = a31\\n    dup a32 = a32\\n    dup a33 = a33\\n    dup a34 = a34\\n    dup a35 = a35\\n    dup a36 = a36\\n    dup a37 = a37\\n    dup a38 = a38\\n    dup a39 = a39\\n    dup a40 = a40\\n    dup a41 = a41\\n    dup a42 = a42\\n    dup a43 = a43\\n    dup a44 = a44\\n    dup a45 = a45\\n    dup a46 = a46\\n    dup a47 = a47\\n    dup a48 = a48\\n    dup a49 = a49\\n\\n    dup c0 = #||||a00 ^ a10| ^ a20| ^ a30| ^ a40|\\n    dup c1 = #||||a01 ^ a11| ^ a21| ^ a31| ^ a41|\\n    dup c2 = #||||a02 ^ a12| ^ a22| ^ a32| ^ a42|\\n    dup c3 = #||||a03 ^ a13| ^ a23| ^ a33| ^ a43|\\n    dup c4 = #||||a04 ^ a14| ^ a24| ^ a34| ^ a44|\\n    dup c5 = #||||a05 ^ a15| ^ a25| ^ a35| ^ a45|\\n    dup c6 = #||||a06 ^ a16| ^ a26| ^ a36| ^ a46|\\n    dup c7 = #||||a07 ^ a17| ^ a27| ^ a37| ^ a47|\\n    dup c8 = #||||a08 ^ a18| ^ a28| ^ a38| ^ a48|\\n    dup c9 = #||||a09 ^ a19| ^ a29| ^ a39| ^ a49|\\n\\n    dup h   = #|c8 ^ ||c2 << 1| | |c3 >> 31|||\\n    dup l   = #|c9 ^ ||c3 << 1| | |c2 >> 31|||\\n    dup a00 = #|a00 ^ h|\\n    dup a01 = #|a01 ^ l|\\n    dup a10 = #|a10 ^ h|\\n    dup a11 = #|a11 ^ l|\\n    dup a20 = #|a20 ^ h|\\n    dup a21 = #|a21 ^ l|\\n    dup a30 = #|a30 ^ h|\\n    dup a31 = #|a31 ^ l|\\n    dup a40 = #|a40 ^ h|\\n    dup a41 = #|a41 ^ l|\\n\\n    dup h   = #|c0 ^ ||c4 << 1| | |c5 >> 31|||\\n    dup l   = #|c1 ^ ||c5 << 1| | |c4 >> 31|||\\n    dup a02 = #|a02 ^ h|\\n    dup a03 = #|a03 ^ l|\\n    dup a12 = #|a12 ^ h|\\n    dup a13 = #|a13 ^ l|\\n    dup a22 = #|a22 ^ h|\\n    dup a23 = #|a23 ^ l|\\n    dup a32 = #|a32 ^ h|\\n    dup a33 = #|a33 ^ l|\\n    dup a42 = #|a42 ^ h|\\n    dup a43 = #|a43 ^ l|\\n\\n    dup h   = #|c2 ^ ||c6 << 1| | |c7 >> 31|||\\n    dup l   = #|c3 ^ ||c7 << 1| | |c6 >> 31|||\\n    dup a04 = #|a04 ^ h|\\n    dup a05 = #|a05 ^ l|\\n    dup a14 = #|a14 ^ h|\\n    dup a15 = #|a15 ^ l|\\n    dup a24 = #|a24 ^ h|\\n    dup a25 = #|a25 ^ l|\\n    dup a34 = #|a34 ^ h|\\n    dup a35 = #|a35 ^ l|\\n    dup a44 = #|a44 ^ h|\\n    dup a45 = #|a45 ^ l|\\n\\n    dup h   = #|c4 ^ ||c8 << 1| | |c9 >> 31|||\\n    dup l   = #|c5 ^ ||c9 << 1| | |c8 >> 31|||\\n    dup a06 = #|a06 ^ h|\\n    dup a07 = #|a07 ^ l|\\n    dup a16 = #|a16 ^ h|\\n    dup a17 = #|a17 ^ l|\\n    dup a26 = #|a26 ^ h|\\n    dup a27 = #|a27 ^ l|\\n    dup a36 = #|a36 ^ h|\\n    dup a37 = #|a37 ^ l|\\n    dup a46 = #|a46 ^ h|\\n    dup a47 = #|a47 ^ l|\\n\\n    dup h   = #|c6 ^ ||c0 << 1| | |c1 >> 31|||\\n    dup l   = #|c7 ^ ||c1 << 1| | |c0 >> 31|||\\n    dup a08 = #|a08 ^ h|\\n    dup a09 = #|a09 ^ l|\\n    dup a18 = #|a18 ^ h|\\n    dup a19 = #|a19 ^ l|\\n    dup a28 = #|a28 ^ h|\\n    dup a29 = #|a29 ^ l|\\n    dup a38 = #|a38 ^ h|\\n    dup a39 = #|a39 ^ l|\\n    dup a48 = #|a48 ^ h|\\n    dup a49 = #|a49 ^ l|\\n\\n    dup b00 = #a00\\n    dup b01 = #a01\\n    dup b32 = #||a11 <<  4| | |a10 >> 28||\\n    dup b33 = #||a10 <<  4| | |a11 >> 28||\\n    dup b14 = #||a20 <<  3| | |a21 >> 29||\\n    dup b15 = #||a21 <<  3| | |a20 >> 29||\\n    dup b46 = #||a31 <<  9| | |a30 >> 23||\\n    dup b47 = #||a30 <<  9| | |a31 >> 23||\\n    dup b28 = #||a40 << 18| | |a41 >> 14||\\n    dup b29 = #||a41 << 18| | |a40 >> 14||\\n    dup b20 = #||a02 <<  1| | |a03 >> 31||\\n    dup b21 = #||a03 <<  1| | |a02 >> 31||\\n    dup b02 = #||a13 << 12| | |a12 >> 20||\\n    dup b03 = #||a12 << 12| | |a13 >> 20||\\n    dup b34 = #||a22 << 10| | |a23 >> 22||\\n    dup b35 = #||a23 << 10| | |a22 >> 22||\\n    dup b16 = #||a33 << 13| | |a32 >> 19||\\n    dup b17 = #||a32 << 13| | |a33 >> 19||\\n    dup b48 = #||a42 << 02| | |a43 >> 30||\\n    dup b49 = #||a43 << 02| | |a42 >> 30||\\n    dup b40 = #||a05 << 30| | |a04 >>  2||\\n    dup b41 = #||a04 << 30| | |a05 >>  2||\\n    dup b22 = #||a14 << 06| | |a15 >> 26||\\n    dup b23 = #||a15 << 06| | |a14 >> 26||\\n    dup b04 = #||a25 << 11| | |a24 >> 21||\\n    dup b05 = #||a24 << 11| | |a25 >> 21||\\n    dup b36 = #||a34 << 15| | |a35 >> 17||\\n    dup b37 = #||a35 << 15| | |a34 >> 17||\\n    dup b18 = #||a45 << 29| | |a44 >>  3||\\n    dup b19 = #||a44 << 29| | |a45 >>  3||\\n    dup b10 = #||a06 << 28| | |a07 >>  4||\\n    dup b11 = #||a07 << 28| | |a06 >>  4||\\n    dup b42 = #||a17 << 23| | |a16 >>  9||\\n    dup b43 = #||a16 << 23| | |a17 >>  9||\\n    dup b24 = #||a26 << 25| | |a27 >>  7||\\n    dup b25 = #||a27 << 25| | |a26 >>  7||\\n    dup b06 = #||a36 << 21| | |a37 >> 11||\\n    dup b07 = #||a37 << 21| | |a36 >> 11||\\n    dup b38 = #||a47 << 24| | |a46 >>  8||\\n    dup b39 = #||a46 << 24| | |a47 >>  8||\\n    dup b30 = #||a08 << 27| | |a09 >>  5||\\n    dup b31 = #||a09 << 27| | |a08 >>  5||\\n    dup b12 = #||a18 << 20| | |a19 >> 12||\\n    dup b13 = #||a19 << 20| | |a18 >> 12||\\n    dup b44 = #||a29 << 07| | |a28 >> 25||\\n    dup b45 = #||a28 << 07| | |a29 >> 25||\\n    dup b26 = #||a38 << 08| | |a39 >> 24||\\n    dup b27 = #||a39 << 08| | |a38 >> 24||\\n    dup b08 = #||a48 << 14| | |a49 >> 18||\\n    dup b09 = #||a49 << 14| | |a48 >> 18||\\n\\n    dup a00 = #|b00 ^ ||0 ~ b02| & b04||\\n    dup a01 = #|b01 ^ ||0 ~ b03| & b05||\\n    dup a10 = #|b10 ^ ||0 ~ b12| & b14||\\n    dup a11 = #|b11 ^ ||0 ~ b13| & b15||\\n    dup a20 = #|b20 ^ ||0 ~ b22| & b24||\\n    dup a21 = #|b21 ^ ||0 ~ b23| & b25||\\n    dup a30 = #|b30 ^ ||0 ~ b32| & b34||\\n    dup a31 = #|b31 ^ ||0 ~ b33| & b35||\\n    dup a40 = #|b40 ^ ||0 ~ b42| & b44||\\n    dup a41 = #|b41 ^ ||0 ~ b43| & b45||\\n    dup a02 = #|b02 ^ ||0 ~ b04| & b06||\\n    dup a03 = #|b03 ^ ||0 ~ b05| & b07||\\n    dup a12 = #|b12 ^ ||0 ~ b14| & b16||\\n    dup a13 = #|b13 ^ ||0 ~ b15| & b17||\\n    dup a22 = #|b22 ^ ||0 ~ b24| & b26||\\n    dup a23 = #|b23 ^ ||0 ~ b25| & b27||\\n    dup a32 = #|b32 ^ ||0 ~ b34| & b36||\\n    dup a33 = #|b33 ^ ||0 ~ b35| & b37||\\n    dup a42 = #|b42 ^ ||0 ~ b44| & b46||\\n    dup a43 = #|b43 ^ ||0 ~ b45| & b47||\\n    dup a04 = #|b04 ^ ||0 ~ b06| & b08||\\n    dup a05 = #|b05 ^ ||0 ~ b07| & b09||\\n    dup a14 = #|b14 ^ ||0 ~ b16| & b18||\\n    dup a15 = #|b15 ^ ||0 ~ b17| & b19||\\n    dup a24 = #|b24 ^ ||0 ~ b26| & b28||\\n    dup a25 = #|b25 ^ ||0 ~ b27| & b29||\\n    dup a34 = #|b34 ^ ||0 ~ b36| & b38||\\n    dup a35 = #|b35 ^ ||0 ~ b37| & b39||\\n    dup a44 = #|b44 ^ ||0 ~ b46| & b48||\\n    dup a45 = #|b45 ^ ||0 ~ b47| & b49||\\n    dup a06 = #|b06 ^ ||0 ~ b08| & b00||\\n    dup a07 = #|b07 ^ ||0 ~ b09| & b01||\\n    dup a16 = #|b16 ^ ||0 ~ b18| & b10||\\n    dup a17 = #|b17 ^ ||0 ~ b19| & b11||\\n    dup a26 = #|b26 ^ ||0 ~ b28| & b20||\\n    dup a27 = #|b27 ^ ||0 ~ b29| & b21||\\n    dup a36 = #|b36 ^ ||0 ~ b38| & b30||\\n    dup a37 = #|b37 ^ ||0 ~ b39| & b31||\\n    dup a46 = #|b46 ^ ||0 ~ b48| & b40||\\n    dup a47 = #|b47 ^ ||0 ~ b49| & b41||\\n    dup a08 = #|b08 ^ ||0 ~ b00| & b02||\\n    dup a09 = #|b09 ^ ||0 ~ b01| & b03||\\n    dup a18 = #|b18 ^ ||0 ~ b10| & b12||\\n    dup a19 = #|b19 ^ ||0 ~ b11| & b13||\\n    dup a28 = #|b28 ^ ||0 ~ b20| & b22||\\n    dup a29 = #|b29 ^ ||0 ~ b21| & b23||\\n    dup a38 = #|b38 ^ ||0 ~ b30| & b32||\\n    dup a39 = #|b39 ^ ||0 ~ b31| & b33||\\n    dup a48 = #|b48 ^ ||0 ~ b40| & b42||\\n    dup a49 = #|b49 ^ ||0 ~ b41| & b43||\\n\\n    dup rcs = # \\n      if |n < 12|\\n      then: if |n < 6|\\n      then: if |n < 3|\\n      then: if |n < 2|\\n      then: if |n < 1|\\n      then: [1,0]\\n      else: [32898,0]\\n      else: [32906,2147483648]\\n      else: if |n < 5|\\n      then: if |n < 4|\\n      then: [2147516416,2147483648]\\n      else: [32907,0]\\n      else: [2147483649,0]\\n      else: if |n < 9|\\n      then: if |n < 8|\\n      then: if |n < 7|\\n      then: [2147516545,2147483648]\\n      else: [32777,2147483648]\\n      else: [138,0]\\n      else: if |n < 11|\\n      then: if |n < 10|\\n      then: [136,0]\\n      else: [2147516425,0]\\n      else: [2147483658,0]\\n      else: if |n < 18|\\n      then: if |n < 15|\\n      then: if |n < 14|\\n      then: if |n < 13|\\n      then: [2147516555,0]\\n      else: [139,2147483648]\\n      else: [32905,2147483648]\\n      else: if |n < 17|\\n      then: if |n < 16|\\n      then: [32771,2147483648]\\n      else: [32770,2147483648]\\n      else: [128,2147483648]\\n      else: if |n < 21|\\n      then: if |n < 20|\\n      then: if |n < 19|\\n      then: [32778,0]\\n      else: [2147483658,2147483648]\\n      else: [2147516545,2147483648]\\n      else: if |n < 23|\\n      then: if |n < 22|\\n      then: [32896,2147483648]\\n      else: [2147483649,0]\\n      else: [2147516424,2147483648]\\n\\n    dup a00 = #|fst rcs ^ a00|\\n    dup a01 = #|snd rcs ^ a01|\\n\\n    (t\\n      #|n + 1|\\n      #a00 #a01 #a02 #a03 #a04 #a05 #a06 #a07 #a08 #a09\\n      #a10 #a11 #a12 #a13 #a14 #a15 #a16 #a17 #a18 #a19\\n      #a20 #a21 #a22 #a23 #a24 #a25 #a26 #a27 #a28 #a29\\n      #a30 #a31 #a32 #a33 #a34 #a35 #a36 #a37 #a38 #a39\\n      #a40 #a41 #a42 #a43 #a44 #a45 #a46 #a47 #a48 #a49))\\n\\ndef Keccak.f: {arr}\\n  dup arr = arr\\n  // transform array of 200 bytes into an array of 50 words\\n  dup arr =\\n    let 2num = {b1 b2 b3 b4} |b1 + ||b2 + ||b3 + |b4 << 8|| << 8|| << 8||\\n    let loop = {arr} {cont t} (arr {k} {b1 b2 b3 b4} (cont (k (2num b1 b2 b3 b4))) t)\\n    dup f = (for ~50 #{cont t} (cont t) #loop #{k} (k {x} x))\\n    #{t} (arr (f t))\\n  dup arr = (for ~24 #(Tup.pushfront 0 arr) #Keccak.f_loop #Tup.popfront)\\n  // transform array of 50 words into an array of 50 tuples of 4 bytes\\n  dup arr =\\n    let 2bytes = {x} {t}\\n      cpy x = x\\n      let b1 = |x % 256|\\n      let x = |x >> 8|\\n      cpy x = x\\n      let b2 = |x % 256|\\n      let x = |x >> 8|\\n      cpy x = x\\n      let b3 = |x % 256|\\n      let b4 = |x >> 8|\\n      (t b1 b2 b3 b4)\\n    let init = {cont t} (cont t)\\n    let loop = {arr} {cont t} (arr {k} {num} (cont (k (2bytes num))) t)\\n    let stop = {k} (k {x} x)\\n    dup f = (for ~50 #init #loop #stop)\\n    #{t} (arr (f t))\\n  // transform array of 50 tuples of 4 bytes into an array of 200 bytes\\n  dup arr =\\n    let init = {cont} (cont {t} t)\\n    let loop = {fun} {cont} (fun {k} {tup} (cont {t} (tup (k t))))\\n    let stop = {k} (k {x} x)\\n    dup f = (for ~50 #init #loop #stop)\\n    #(arr f)\\n  #arr\\n\\ndef Keccak.update_zero: {t k} (k t)\\ndef Keccak.pushfront_update: {f update} {t k} {x} (update (t (f x)) k)\\ndef Keccak.pushback_update: {f update} {t k} (update t {tup} {x} (k (tup (f x))))\\ndef Keccak.apply_update: {update arr} {t} (arr (update t {x} x))\\n\\ndef Keccak.256: {bytes}\\n  let state = (for ~200 #{t} t #(Tup.pushfront #0) #{x} x)\\n  let update = Keccak.update_zero\\n  let fold_cons = {x h i state update F}\\n    cpy i = i\\n    (if ||i % 136| == 135|\\n    then: {x h i state update F}\\n      dup x = x\\n      dup state = state\\n      dup update = update\\n      dup F = F\\n      (h |i + 1| #(F (Keccak.apply_update (Keccak.pushback_update {y} |x ^ y| update) state)) #Keccak.update_zero #F)\\n    else: {x h i state update F}\\n      dup x = x\\n      dup update = update\\n      (h |i + 1| state #(Keccak.pushback_update {y} |x ^ y| update) F)\\n    x h i state update F)\\n  let fold_nil = {i state update F}\\n    dup state = state\\n    dup update = update\\n    dup F = F\\n    dup state = #(Keccak.apply_update (Keccak.pushback_update {y} |y ^ 1| update) state)\\n    // xor the position 135 of the state with 0x80\\n    dup state =\\n      dup f = (for ~135 #{t x} (t |x ^ 128|) #{fun t x} (fun (t x)) #{x} x)\\n      #{t} (state (f t))\\n    dup state = #(F state)\\n    #(state {a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23 a24 a25 a26 a27 a28 a29 a30 a31 a32 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -}\\n      (List.cons a1 (List.cons a2 (List.cons a3 (List.cons a4 (List.cons a5 (List.cons a6 (List.cons a7 (List.cons a8 (List.cons a9 (List.cons a10 (List.cons a11 (List.cons a12 (List.cons a13 (List.cons a14 (List.cons a15 (List.cons a16 (List.cons a17 (List.cons a18 (List.cons a19 (List.cons a20 (List.cons a21 (List.cons a22 (List.cons a23 (List.cons a24 (List.cons a25 (List.cons a26 (List.cons a27 (List.cons a28 (List.cons a29 (List.cons a30 (List.cons a31 (List.cons a32 List.nil)))))))))))))))))))))))))))))))))\\n  dup fold = (bytes #fold_cons)\\n# (fold fold_nil 0 state #update #Keccak.f)\\n\\ndef Keccak.bytes_to_hex: {xs}\\n  (from_chars\\n  {Cons}\\n  dup Cons = Cons\\n  dup fold =\\n    (xs #{x h}\\n      cpy x = x\\n      let a0 = (Num.to_char |x % 16|)\\n      let a1 = (Num.to_char |x / 16|)\\n      (Cons a1 (Cons a0 h)))\\n  #{n} (fold n))\\n\\ndef keccak: Keccak.ex\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/keccak.fmc?");

/***/ }),

/***/ "../formality/stdlib/list.fmc":
/*!************************************!*\
  !*** ../formality/stdlib/list.fmc ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// TODO: continue the update of this file\\n\\ndef List.ex: (reverse (map (List.cons #3 (List.cons #4 (List.cons #7 (List.cons #2 (List.cons #0 List.nil))))) #{x} |x * 2|))\\ndef List.ex.foldr: (foldr example_list #{x y} |x + y|)\\n\\ndef List.cons: {x xs}\\n  {Cons}\\n  dup x    = x\\n  dup Cons = Cons\\n  dup func = (xs #Cons)\\n  # {nil} (Cons x (func nil))\\n\\ndef List.nil:\\n  {Cons}\\n  # {nil} nil\\n\\ndef List.to_stack: {list}\\n  dup F = (list #Cons)\\n  # (F nil)\\n\\ndef List.build: {len init loop} {cons}\\n  dup loop = loop\\n  dup init = init\\n  dup cons = cons\\n  dup fold = (len #{list state}\\n    get [state, element] = (loop state)\\n    (cons element (list state)))\\n  # {nil} (fold {state}nil init)\\n\\n// Concatenates two lists\\ndef List.concat: {a b}\\n  {Cons}\\n  dup Cons = Cons\\n  dup append-a = (a #Cons)\\n  dup append-b = (b #Cons)\\n  # {nil} (append-a (append-b nil))\\n\\n// Converts Scott to Church in O(len).\\ndef List.fold_f: {len Cons}\\n  dup Cons = Cons\\n  let func = {cont list}\\n    let case_cons = {head tail nil} (Cons head (cont tail nil))\\n    let case_nil  = {nil} nil\\n    (list case_cons case_nil)\\n  dup fold = (len #func)\\n  # {nil list} (fold {tail}{nil}nil list nil)\\n\\n// Non-fused version of the function above.\\ndef List.fold: {len}\\n  dup fold_f = (List.fold_f len #List.cons)\\n  # {list} (fold_f List.nil list)\\n\\ndef List.map: {as f Cons}\\n  dup f = f\\n  dup Cons = Cons\\n  let case_cons = {a} (Cons (f a))\\n  dup A = (as #case_cons)\\n  # {Nil} (A Nil)\\n\\ndef List.reverse:\\n  {as}\\n  let iterate = {xs ys Cons}\\n    dup Cons = Cons\\n    dup rec = (xs #{x h p} (h (Cons x p)))\\n    dup p = (ys #Cons)\\n    #{N} (rec {p} p (p N))\\n  (iterate as List.nil)\\n\\ndef List.filter: {xs p}\\n  dup p = p\\n  {Cons}\\n  dup Cons = Cons\\n  dup rec = (xs #{x h}\\n    dup x = x\\n    (p #x {r} (Cons #x r) {r} r h))\\n  #{N} (rec N)\\n\\ndef List.foldl: {as op}\\n  dup op = op\\n  dup rec = (as #{a h} (op h a))\\n  #{b} (rec b)\\n\\ndef List.foldr: {as op}\\n  dup op = op\\n  dup rec = (as #{a h} (op a h))\\n  # {b} (rec b)\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/list.fmc?");

/***/ }),

/***/ "../formality/stdlib/main.fmc":
/*!************************************!*\
  !*** ../formality/stdlib/main.fmc ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def add_test:\\n  |3 + 2|\\n\\ndef mul_test:\\n  |3 * 2|\\n\\ndef tup_test:\\n  (tup_fst (Tup 42 1337))\\n\\ndef pair_test:\\n  fst [42 , 1337]\\n\\ndef list_test:\\n  (Cons #1 (Cons #2 (Cons #3 Nil)))\\n\\ndef list_fold_test:\\n  dup fold = (list_fold ~3)\\n  # (fold list_test)\\n\\ndef list_fold_f_test:\\n  {Cons}\\n  dup fold_f = (list_fold_f ~3 Cons)\\n  # {Nil} (fold_f Nil list_test)\\n\\ndef if_test:\\n  if 1\\n  then: \\\"cond is true\\\"\\n  else: \\\"cond is false\\\"\\n\\ndef cpy_test:\\n  cpy num = 42\\n  [[num, num], |num + num|]\\n\\ndef prj_test:\\n  get [fst, snd] = [42, 1337]\\n  (tup fst snd)\\n\\ndef fib_test:\\n  (fib ~65536)\\n\\ndef to_chars_test:\\n  (to_chars \\\"abcdefgh\\\")\\n\\ndef string_concat_test:\\n  (string_concat \\\"Hello, \\\" \\\"world!\\\")\\n\\ndef sum_test:\\n  let upto = ~100000\\n  let init =\\n    [0, 0]\\n  let loop = {state}\\n    get [idx, sum] = state\\n    cpy idx        = idx\\n    [|idx + 1|, |sum + idx|]\\n  let done = {state} snd state\\n  (for upto #init #loop #done)\\n\\ndef term_test:\\n  term_example\\n\\ndef array_test:\\n  array_example\\n\\ndef utf8_test:\\n  (to_codepoints \\\"Î»æå¸æ\\\")\\n\\ndef utf8_conversion_test:\\n  (codepoint_to_ncr (ncr_to_codepoint 955))\\n\\ndef from_codepoints_test:\\n  let string = \\\"Î»abc\\\"\\n  let codepoints = (to_codepoints string)\\n  [({x} (from_chars (to_chars [TEXT, x])) codepoints),\\n  (from_codepoints codepoints)]\\n\\ndef main:\\n  string_concat_test\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/main.fmc?");

/***/ }),

/***/ "../formality/stdlib/maybe.fmc":
/*!*************************************!*\
  !*** ../formality/stdlib/maybe.fmc ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// TODO: update this file\\n\\ndef None:\\n  {None Just}\\n  None\\n\\ndef Just: {val}\\n  {None Just}\\n  (Just val)\\n\\ndef maybe_concat: {a b}\\n  (a b Just)\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/maybe.fmc?");

/***/ }),

/***/ "../formality/stdlib/nat.fmc":
/*!***********************************!*\
  !*** ../formality/stdlib/nat.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Natural numbers\\n\\ndef Nat.zero:\\n  {Succ Zero}\\n  Zero\\n\\ndef Nat.succ: {pred}\\n  {Succ Zero}\\n  (Succ pred)\\n\\ndef Nat.to_chars: {n}\\n  let call = {go} {nat}\\n    let case_succ = {n} (List.concat (to_chars \\\"S\\\") (go n))\\n    let case_zero = (to_chars \\\"Z\\\")\\n    (nat case_succ case_zero)\\n  let stop = {nat} List.nil\\n  (n #call #stop)\\n\\ndef Nat.to_string: {n}\\n  dup func = (Nat.to_chars n)\\n  # {n} (from_chars (func n))\\n\\ndef Nat.copy: {n}\\n  let call = {go} {nat}\\n    let case_succ = {n ns}\\n      get [n0, n1] = ns\\n      (go n [(Nat.succ n0), (Nat.succ n1)])\\n    let case_zero = {ns} ns\\n    (nat case_succ case_zero)\\n  let stop = {n ns} ns\\n  dup func = (rec n #call #stop)\\n  # {n} (func n [Nat.zero, Nat.zero])\\n\\ndef Cmp.lt: {Lt Eq Gt} Lt\\ndef Cmp.eq: {Lt Eq Gt} Eq\\ndef Cmp.gt: {Lt Eq Gt} Gt\\n\\ndef Nat.compare: {n}\\n  let call = {go} {a}\\n    let case_a_succ = {a_pred} {b}\\n      let case_b_succ = {b_pred} (go a_pred b_pred)\\n      let case_b_zero = Cmp.gt\\n      (b case_b_succ case_b_zero)\\n    let case_a_zero = {b}\\n      let case_b_succ = {b_pred} Cmp.lt\\n      let case_b_zero = Cmp.eq\\n      (b case_b_succ case_b_zero)\\n    (a case_a_succ case_a_zero)\\n  let stop = {a b} Cmp.eq\\n  (rec n #call #stop)\\n\\ndef nat:\\n  dup cmp = (Nat.compare ~6)\\n  let a = (Nat.succ (Nat.succ Nat.zero))\\n  let b = (Nat.succ (Nat.succ (Nat.succ Nat.zero)))\\n  # (cmp a b)\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/nat.fmc?");

/***/ }),

/***/ "../formality/stdlib/num.fmc":
/*!***********************************!*\
  !*** ../formality/stdlib/num.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def Num.ex:\\n  (Num.fib ~100000)\\n\\ndef Num.boxed_add: {x y}\\n  dup x = x\\n  dup y = y\\n  # |x + y|\\n\\ndef Num.dif: {a b}\\n  cpy a = a\\n  cpy b = b\\n  if |a > b|\\n  then: |a - b|\\n  else: |b - a|\\n\\ndef Num.to_char: {n}\\n  cpy n = n\\n  if |n < 10|\\n  then: |n + 48|\\n  else: |n + 87|\\n\\ndef Num.max: {a b}\\n  cpy a = a\\n  cpy b = b\\n  if |a > b| then:\\n    a\\n  else:\\n    b\\n\\ndef Num.min: {a b}\\n  cpy a = a\\n  cpy b = b\\n  if |a < b| then:\\n    a\\n  else:\\n    b\\n\\n// Num.box_byte\\n// : {n : Num} !Num\\ndef Num.box_byte: {n}\\n  cpy n = n\\n  dup b00 = if ||n >>  0| & 1| [#{x}|x + 0x1|, #{x}x]\\n  dup b01 = if ||n >>  1| & 1| [#{x}|x + 0x2|, #{x}x]\\n  dup b02 = if ||n >>  2| & 1| [#{x}|x + 0x4|, #{x}x]\\n  dup b03 = if ||n >>  3| & 1| [#{x}|x + 0x8|, #{x}x]\\n  dup b04 = if ||n >>  4| & 1| [#{x}|x + 0x10|, #{x}x]\\n  dup b05 = if ||n >>  5| & 1| [#{x}|x + 0x20|, #{x}x]\\n  dup b06 = if ||n >>  6| & 1| [#{x}|x + 0x40|, #{x}x]\\n  dup b07 = if ||n >>  7| & 1| [#{x}|x + 0x80|, #{x}x]\\n  # (b07 (b06 (b05 (b04 (b03 (b02 (b01 (b00 0))))))))\\n\\n// Num.box\\n// : {n : Num} !Num\\ndef Num.box: {n}\\n  cpy n = n\\n  dup b00 = if ||n >>  0| & 1| [#{x}|x + 0x1|, #{x}x]\\n  dup b01 = if ||n >>  1| & 1| [#{x}|x + 0x2|, #{x}x]\\n  dup b02 = if ||n >>  2| & 1| [#{x}|x + 0x4|, #{x}x]\\n  dup b03 = if ||n >>  3| & 1| [#{x}|x + 0x8|, #{x}x]\\n  dup b04 = if ||n >>  4| & 1| [#{x}|x + 0x10|, #{x}x]\\n  dup b05 = if ||n >>  5| & 1| [#{x}|x + 0x20|, #{x}x]\\n  dup b06 = if ||n >>  6| & 1| [#{x}|x + 0x40|, #{x}x]\\n  dup b07 = if ||n >>  7| & 1| [#{x}|x + 0x80|, #{x}x]\\n  dup b08 = if ||n >>  8| & 1| [#{x}|x + 0x100|, #{x}x]\\n  dup b09 = if ||n >>  9| & 1| [#{x}|x + 0x200|, #{x}x]\\n  dup b10 = if ||n >> 10| & 1| [#{x}|x + 0x400|, #{x}x]\\n  dup b11 = if ||n >> 11| & 1| [#{x}|x + 0x800|, #{x}x]\\n  dup b12 = if ||n >> 12| & 1| [#{x}|x + 0x1000|, #{x}x]\\n  dup b13 = if ||n >> 13| & 1| [#{x}|x + 0x2000|, #{x}x]\\n  dup b14 = if ||n >> 14| & 1| [#{x}|x + 0x4000|, #{x}x]\\n  dup b15 = if ||n >> 15| & 1| [#{x}|x + 0x8000|, #{x}x]\\n  dup b16 = if ||n >> 16| & 1| [#{x}|x + 0x10000|, #{x}x]\\n  dup b17 = if ||n >> 17| & 1| [#{x}|x + 0x20000|, #{x}x]\\n  dup b18 = if ||n >> 18| & 1| [#{x}|x + 0x40000|, #{x}x]\\n  dup b19 = if ||n >> 19| & 1| [#{x}|x + 0x80000|, #{x}x]\\n  dup b20 = if ||n >> 20| & 1| [#{x}|x + 0x100000|, #{x}x]\\n  dup b21 = if ||n >> 21| & 1| [#{x}|x + 0x200000|, #{x}x]\\n  dup b22 = if ||n >> 22| & 1| [#{x}|x + 0x400000|, #{x}x]\\n  dup b23 = if ||n >> 23| & 1| [#{x}|x + 0x800000|, #{x}x]\\n  dup b24 = if ||n >> 24| & 1| [#{x}|x + 0x1000000|, #{x}x]\\n  dup b25 = if ||n >> 25| & 1| [#{x}|x + 0x2000000|, #{x}x]\\n  dup b26 = if ||n >> 26| & 1| [#{x}|x + 0x4000000|, #{x}x]\\n  dup b27 = if ||n >> 27| & 1| [#{x}|x + 0x8000000|, #{x}x]\\n  dup b28 = if ||n >> 28| & 1| [#{x}|x + 0x10000000|, #{x}x]\\n  dup b29 = if ||n >> 29| & 1| [#{x}|x + 0x20000000|, #{x}x]\\n  dup b30 = if ||n >> 30| & 1| [#{x}|x + 0x40000000|, #{x}x]\\n  dup b31 = if ||n >> 31| & 1| [#{x}|x + 0x80000000|, #{x}x]\\n  # (b31 (b30 (b29 (b28 (b27 (b26 (b25 (b24\\n    (b23 (b22 (b21 (b20 (b19 (b18 (b17 (b16\\n    (b15 (b14 (b13 (b12 (b11 (b10 (b09 (b08\\n    (b07 (b06 (b05 (b04 (b03 (b02 (b01 (b00\\n      0))))))))))))))))))))))))))))))))\\n\\ndef Num.to_chars: {mlen}\\n  let call = {go n list}\\n    cpy n    = n\\n    let list = (List.cons (Num.box_byte (Num.to_char |n % 10|)) list)\\n    (go |n / 10| list)\\n  let stop = {n list}\\n    list\\n  dup func = (rec mlen #call #stop)\\n  # {n} (func n List.nil)\\n\\ndef Num.to_string: {mlen}\\n  dup to_chars = (Num.to_chars mlen)\\n  # {num} (from_chars (to_chars num))\\n\\ndef Num.from_nat: {n}\\n  dup fold = (n #{x}|x + 1|)\\n  # (fold 0)\\n\\ndef Num.sqrt: {n}\\n  |n ^^ 2147483648|\\n\\n// Gets the nth number of the Fibonacci sequence\\ndef Num.fib: {n}\\n  let init = [0,1]\\n  let loop = {state}\\n    get [a, b] = state\\n    cpy b      = b\\n    [b, |a + b|]\\n  let stop = {state}\\n    (snd state)\\n  (for n #init #loop #stop)\\n\\n//def Num.box2:\\n  //let call = {go n}\\n    //cpy n = n\\n    //dup r = (go |n / 2|)\\n    //if |n & 1|\\n    //then: #||r * 2| + 1|\\n    //else: #|r * 2|\\n  //let stop = {n} #0\\n  //(rec ~32 #call #stop)\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/num.fmc?");

/***/ }),

/***/ "../formality/stdlib/pair.fmc":
/*!************************************!*\
  !*** ../formality/stdlib/pair.fmc ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Pair\\n// | A simple, non-dependent pair\\n// TODO: annotate type (follow Bits.fmc)\\ndef Pair: {a b} [a, b]\\n\\n// TODO: annotate type (follow Bits.fmc)\\ndef Pair.fst: {pair}\\n  fst pair\\n\\n// TODO: annotate type (follow Bits.fmc)\\ndef Pair.snd: {pair}\\n  snd pair\\n\\n// TODO: annotate type (follow Bits.fmc)\\ndef Pair.prj: {pair func}\\n  get [val0, val1] = pair\\n  (func val0 val1)\\n\\n// TODO: annotate type (follow Bits.fmc)\\ndef Pair.swap: {pair}\\n  get [a, b] = pair\\n  [b, a]\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/pair.fmc?");

/***/ }),

/***/ "../formality/stdlib/pbt.fmc":
/*!***********************************!*\
  !*** ../formality/stdlib/pbt.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def PBT.0: {b n}\\n  dup b = b\\n  dup n = n\\n  # n\\n\\ndef PBT.1: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  # A\\n\\ndef PBT.2: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  # B\\n\\ndef PBT.3: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  # C\\n\\ndef PBT.4: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  # D\\n\\ndef PBT.5: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  # E\\n\\ndef PBT.6: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  # F\\n\\ndef PBT.7: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  # G\\n\\ndef PBT.8: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  # H\\n\\ndef PBT.9: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  # I\\n\\ndef PBT.10: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  # J\\n\\ndef PBT.11: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  # K\\n\\ndef PBT.12: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  # L\\n\\ndef PBT.13: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  # M\\n\\ndef PBT.14: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  # N\\n\\ndef PBT.15: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  dup O = # (b N N)\\n  # O\\n\\ndef PBT.16: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  dup O = # (b N N)\\n  dup P = # (b O O)\\n  # P\\n\\ndef PBT.17: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  dup O = # (b N N)\\n  dup P = # (b O O)\\n  dup Q = # (b P P)\\n  # Q\\n\\ndef PBT.18: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  dup O = # (b N N)\\n  dup P = # (b O O)\\n  dup Q = # (b P P)\\n  dup R = # (b Q Q)\\n  # R\\n\\ndef PBT.19: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  dup O = # (b N N)\\n  dup P = # (b O O)\\n  dup Q = # (b P P)\\n  dup R = # (b Q Q)\\n  dup S = # (b R R)\\n  # S\\n\\ndef PBT.20: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  dup O = # (b N N)\\n  dup P = # (b O O)\\n  dup Q = # (b P P)\\n  dup R = # (b Q Q)\\n  dup S = # (b R R)\\n  dup T = # (b S S)\\n  # T\\n\\ndef PBT.21: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  dup O = # (b N N)\\n  dup P = # (b O O)\\n  dup Q = # (b P P)\\n  dup R = # (b Q Q)\\n  dup S = # (b R R)\\n  dup T = # (b S S)\\n  dup U = # (b T T)\\n  # U\\n\\ndef PBT.22: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  dup O = # (b N N)\\n  dup P = # (b O O)\\n  dup Q = # (b P P)\\n  dup R = # (b Q Q)\\n  dup S = # (b R R)\\n  dup T = # (b S S)\\n  dup U = # (b T T)\\n  dup V = # (b U U)\\n  # V\\n\\ndef PBT.23: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  dup O = # (b N N)\\n  dup P = # (b O O)\\n  dup Q = # (b P P)\\n  dup R = # (b Q Q)\\n  dup S = # (b R R)\\n  dup T = # (b S S)\\n  dup U = # (b T T)\\n  dup V = # (b U U)\\n  dup W = # (b V V)\\n  # W\\n\\ndef PBT.24: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  dup O = # (b N N)\\n  dup P = # (b O O)\\n  dup Q = # (b P P)\\n  dup R = # (b Q Q)\\n  dup S = # (b R R)\\n  dup T = # (b S S)\\n  dup U = # (b T T)\\n  dup V = # (b U U)\\n  dup W = # (b V V)\\n  dup X = # (b W W)\\n  # X\\n\\ndef PBT.25: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  dup O = # (b N N)\\n  dup P = # (b O O)\\n  dup Q = # (b P P)\\n  dup R = # (b Q Q)\\n  dup S = # (b R R)\\n  dup T = # (b S S)\\n  dup U = # (b T T)\\n  dup V = # (b U U)\\n  dup W = # (b V V)\\n  dup X = # (b W W)\\n  dup Y = # (b X X)\\n  # Y\\n\\ndef PBT.26: {b n}\\n  dup b = b\\n  dup n = n\\n  dup A = # (b n n)\\n  dup B = # (b A A)\\n  dup C = # (b B B)\\n  dup D = # (b C C)\\n  dup E = # (b D D)\\n  dup F = # (b E E)\\n  dup G = # (b F F)\\n  dup H = # (b G G)\\n  dup I = # (b H H)\\n  dup J = # (b I I)\\n  dup K = # (b J J)\\n  dup L = # (b K K)\\n  dup M = # (b L L)\\n  dup N = # (b M M)\\n  dup O = # (b N N)\\n  dup P = # (b O O)\\n  dup Q = # (b P P)\\n  dup R = # (b Q Q)\\n  dup S = # (b R R)\\n  dup T = # (b S S)\\n  dup U = # (b T T)\\n  dup V = # (b U U)\\n  dup W = # (b V V)\\n  dup X = # (b W W)\\n  dup Y = # (b X X)\\n  dup Z = # (b Y Y)\\n  # Z\\n\\ndef PBT.256: {b n}\\n  dup b = b\\n  dup n = n\\n  dup l0000 = # (b n n)\\n  dup l0001 = # (b l0000 l0000)\\n  dup l0002 = # (b l0001 l0001)\\n  dup l0003 = # (b l0002 l0002)\\n  dup l0004 = # (b l0003 l0003)\\n  dup l0005 = # (b l0004 l0004)\\n  dup l0006 = # (b l0005 l0005)\\n  dup l0007 = # (b l0006 l0006)\\n  dup l0008 = # (b l0007 l0007)\\n  dup l0009 = # (b l0008 l0008)\\n  dup l0010 = # (b l0009 l0009)\\n  dup l0011 = # (b l0010 l0010)\\n  dup l0012 = # (b l0011 l0011)\\n  dup l0013 = # (b l0012 l0012)\\n  dup l0014 = # (b l0013 l0013)\\n  dup l0015 = # (b l0014 l0014)\\n  dup l0016 = # (b l0015 l0015)\\n  dup l0017 = # (b l0016 l0016)\\n  dup l0018 = # (b l0017 l0017)\\n  dup l0019 = # (b l0018 l0018)\\n  dup l0020 = # (b l0019 l0019)\\n  dup l0021 = # (b l0020 l0020)\\n  dup l0022 = # (b l0021 l0021)\\n  dup l0023 = # (b l0022 l0022)\\n  dup l0024 = # (b l0023 l0023)\\n  dup l0025 = # (b l0024 l0024)\\n  dup l0026 = # (b l0025 l0025)\\n  dup l0027 = # (b l0026 l0026)\\n  dup l0028 = # (b l0027 l0027)\\n  dup l0029 = # (b l0028 l0028)\\n  dup l0030 = # (b l0029 l0029)\\n  dup l0031 = # (b l0030 l0030)\\n  dup l0032 = # (b l0031 l0031)\\n  dup l0033 = # (b l0032 l0032)\\n  dup l0034 = # (b l0033 l0033)\\n  dup l0035 = # (b l0034 l0034)\\n  dup l0036 = # (b l0035 l0035)\\n  dup l0037 = # (b l0036 l0036)\\n  dup l0038 = # (b l0037 l0037)\\n  dup l0039 = # (b l0038 l0038)\\n  dup l0040 = # (b l0039 l0039)\\n  dup l0041 = # (b l0040 l0040)\\n  dup l0042 = # (b l0041 l0041)\\n  dup l0043 = # (b l0042 l0042)\\n  dup l0044 = # (b l0043 l0043)\\n  dup l0045 = # (b l0044 l0044)\\n  dup l0046 = # (b l0045 l0045)\\n  dup l0047 = # (b l0046 l0046)\\n  dup l0048 = # (b l0047 l0047)\\n  dup l0049 = # (b l0048 l0048)\\n  dup l0050 = # (b l0049 l0049)\\n  dup l0051 = # (b l0050 l0050)\\n  dup l0052 = # (b l0051 l0051)\\n  dup l0053 = # (b l0052 l0052)\\n  dup l0054 = # (b l0053 l0053)\\n  dup l0055 = # (b l0054 l0054)\\n  dup l0056 = # (b l0055 l0055)\\n  dup l0057 = # (b l0056 l0056)\\n  dup l0058 = # (b l0057 l0057)\\n  dup l0059 = # (b l0058 l0058)\\n  dup l0060 = # (b l0059 l0059)\\n  dup l0061 = # (b l0060 l0060)\\n  dup l0062 = # (b l0061 l0061)\\n  dup l0063 = # (b l0062 l0062)\\n  dup l0064 = # (b l0063 l0063)\\n  dup l0065 = # (b l0064 l0064)\\n  dup l0066 = # (b l0065 l0065)\\n  dup l0067 = # (b l0066 l0066)\\n  dup l0068 = # (b l0067 l0067)\\n  dup l0069 = # (b l0068 l0068)\\n  dup l0070 = # (b l0069 l0069)\\n  dup l0071 = # (b l0070 l0070)\\n  dup l0072 = # (b l0071 l0071)\\n  dup l0073 = # (b l0072 l0072)\\n  dup l0074 = # (b l0073 l0073)\\n  dup l0075 = # (b l0074 l0074)\\n  dup l0076 = # (b l0075 l0075)\\n  dup l0077 = # (b l0076 l0076)\\n  dup l0078 = # (b l0077 l0077)\\n  dup l0079 = # (b l0078 l0078)\\n  dup l0080 = # (b l0079 l0079)\\n  dup l0081 = # (b l0080 l0080)\\n  dup l0082 = # (b l0081 l0081)\\n  dup l0083 = # (b l0082 l0082)\\n  dup l0084 = # (b l0083 l0083)\\n  dup l0085 = # (b l0084 l0084)\\n  dup l0086 = # (b l0085 l0085)\\n  dup l0087 = # (b l0086 l0086)\\n  dup l0088 = # (b l0087 l0087)\\n  dup l0089 = # (b l0088 l0088)\\n  dup l0090 = # (b l0089 l0089)\\n  dup l0091 = # (b l0090 l0090)\\n  dup l0092 = # (b l0091 l0091)\\n  dup l0093 = # (b l0092 l0092)\\n  dup l0094 = # (b l0093 l0093)\\n  dup l0095 = # (b l0094 l0094)\\n  dup l0096 = # (b l0095 l0095)\\n  dup l0097 = # (b l0096 l0096)\\n  dup l0098 = # (b l0097 l0097)\\n  dup l0099 = # (b l0098 l0098)\\n  dup l0100 = # (b l0099 l0099)\\n  dup l0101 = # (b l0100 l0100)\\n  dup l0102 = # (b l0101 l0101)\\n  dup l0103 = # (b l0102 l0102)\\n  dup l0104 = # (b l0103 l0103)\\n  dup l0105 = # (b l0104 l0104)\\n  dup l0106 = # (b l0105 l0105)\\n  dup l0107 = # (b l0106 l0106)\\n  dup l0108 = # (b l0107 l0107)\\n  dup l0109 = # (b l0108 l0108)\\n  dup l0110 = # (b l0109 l0109)\\n  dup l0111 = # (b l0110 l0110)\\n  dup l0112 = # (b l0111 l0111)\\n  dup l0113 = # (b l0112 l0112)\\n  dup l0114 = # (b l0113 l0113)\\n  dup l0115 = # (b l0114 l0114)\\n  dup l0116 = # (b l0115 l0115)\\n  dup l0117 = # (b l0116 l0116)\\n  dup l0118 = # (b l0117 l0117)\\n  dup l0119 = # (b l0118 l0118)\\n  dup l0120 = # (b l0119 l0119)\\n  dup l0121 = # (b l0120 l0120)\\n  dup l0122 = # (b l0121 l0121)\\n  dup l0123 = # (b l0122 l0122)\\n  dup l0124 = # (b l0123 l0123)\\n  dup l0125 = # (b l0124 l0124)\\n  dup l0126 = # (b l0125 l0125)\\n  dup l0127 = # (b l0126 l0126)\\n  dup l0128 = # (b l0127 l0127)\\n  dup l0129 = # (b l0128 l0128)\\n  dup l0130 = # (b l0129 l0129)\\n  dup l0131 = # (b l0130 l0130)\\n  dup l0132 = # (b l0131 l0131)\\n  dup l0133 = # (b l0132 l0132)\\n  dup l0134 = # (b l0133 l0133)\\n  dup l0135 = # (b l0134 l0134)\\n  dup l0136 = # (b l0135 l0135)\\n  dup l0137 = # (b l0136 l0136)\\n  dup l0138 = # (b l0137 l0137)\\n  dup l0139 = # (b l0138 l0138)\\n  dup l0140 = # (b l0139 l0139)\\n  dup l0141 = # (b l0140 l0140)\\n  dup l0142 = # (b l0141 l0141)\\n  dup l0143 = # (b l0142 l0142)\\n  dup l0144 = # (b l0143 l0143)\\n  dup l0145 = # (b l0144 l0144)\\n  dup l0146 = # (b l0145 l0145)\\n  dup l0147 = # (b l0146 l0146)\\n  dup l0148 = # (b l0147 l0147)\\n  dup l0149 = # (b l0148 l0148)\\n  dup l0150 = # (b l0149 l0149)\\n  dup l0151 = # (b l0150 l0150)\\n  dup l0152 = # (b l0151 l0151)\\n  dup l0153 = # (b l0152 l0152)\\n  dup l0154 = # (b l0153 l0153)\\n  dup l0155 = # (b l0154 l0154)\\n  dup l0156 = # (b l0155 l0155)\\n  dup l0157 = # (b l0156 l0156)\\n  dup l0158 = # (b l0157 l0157)\\n  dup l0159 = # (b l0158 l0158)\\n  dup l0160 = # (b l0159 l0159)\\n  dup l0161 = # (b l0160 l0160)\\n  dup l0162 = # (b l0161 l0161)\\n  dup l0163 = # (b l0162 l0162)\\n  dup l0164 = # (b l0163 l0163)\\n  dup l0165 = # (b l0164 l0164)\\n  dup l0166 = # (b l0165 l0165)\\n  dup l0167 = # (b l0166 l0166)\\n  dup l0168 = # (b l0167 l0167)\\n  dup l0169 = # (b l0168 l0168)\\n  dup l0170 = # (b l0169 l0169)\\n  dup l0171 = # (b l0170 l0170)\\n  dup l0172 = # (b l0171 l0171)\\n  dup l0173 = # (b l0172 l0172)\\n  dup l0174 = # (b l0173 l0173)\\n  dup l0175 = # (b l0174 l0174)\\n  dup l0176 = # (b l0175 l0175)\\n  dup l0177 = # (b l0176 l0176)\\n  dup l0178 = # (b l0177 l0177)\\n  dup l0179 = # (b l0178 l0178)\\n  dup l0180 = # (b l0179 l0179)\\n  dup l0181 = # (b l0180 l0180)\\n  dup l0182 = # (b l0181 l0181)\\n  dup l0183 = # (b l0182 l0182)\\n  dup l0184 = # (b l0183 l0183)\\n  dup l0185 = # (b l0184 l0184)\\n  dup l0186 = # (b l0185 l0185)\\n  dup l0187 = # (b l0186 l0186)\\n  dup l0188 = # (b l0187 l0187)\\n  dup l0189 = # (b l0188 l0188)\\n  dup l0190 = # (b l0189 l0189)\\n  dup l0191 = # (b l0190 l0190)\\n  dup l0192 = # (b l0191 l0191)\\n  dup l0193 = # (b l0192 l0192)\\n  dup l0194 = # (b l0193 l0193)\\n  dup l0195 = # (b l0194 l0194)\\n  dup l0196 = # (b l0195 l0195)\\n  dup l0197 = # (b l0196 l0196)\\n  dup l0198 = # (b l0197 l0197)\\n  dup l0199 = # (b l0198 l0198)\\n  dup l0200 = # (b l0199 l0199)\\n  dup l0201 = # (b l0200 l0200)\\n  dup l0202 = # (b l0201 l0201)\\n  dup l0203 = # (b l0202 l0202)\\n  dup l0204 = # (b l0203 l0203)\\n  dup l0205 = # (b l0204 l0204)\\n  dup l0206 = # (b l0205 l0205)\\n  dup l0207 = # (b l0206 l0206)\\n  dup l0208 = # (b l0207 l0207)\\n  dup l0209 = # (b l0208 l0208)\\n  dup l0210 = # (b l0209 l0209)\\n  dup l0211 = # (b l0210 l0210)\\n  dup l0212 = # (b l0211 l0211)\\n  dup l0213 = # (b l0212 l0212)\\n  dup l0214 = # (b l0213 l0213)\\n  dup l0215 = # (b l0214 l0214)\\n  dup l0216 = # (b l0215 l0215)\\n  dup l0217 = # (b l0216 l0216)\\n  dup l0218 = # (b l0217 l0217)\\n  dup l0219 = # (b l0218 l0218)\\n  dup l0220 = # (b l0219 l0219)\\n  dup l0221 = # (b l0220 l0220)\\n  dup l0222 = # (b l0221 l0221)\\n  dup l0223 = # (b l0222 l0222)\\n  dup l0224 = # (b l0223 l0223)\\n  dup l0225 = # (b l0224 l0224)\\n  dup l0226 = # (b l0225 l0225)\\n  dup l0227 = # (b l0226 l0226)\\n  dup l0228 = # (b l0227 l0227)\\n  dup l0229 = # (b l0228 l0228)\\n  dup l0230 = # (b l0229 l0229)\\n  dup l0231 = # (b l0230 l0230)\\n  dup l0232 = # (b l0231 l0231)\\n  dup l0233 = # (b l0232 l0232)\\n  dup l0234 = # (b l0233 l0233)\\n  dup l0235 = # (b l0234 l0234)\\n  dup l0236 = # (b l0235 l0235)\\n  dup l0237 = # (b l0236 l0236)\\n  dup l0238 = # (b l0237 l0237)\\n  dup l0239 = # (b l0238 l0238)\\n  dup l0240 = # (b l0239 l0239)\\n  dup l0241 = # (b l0240 l0240)\\n  dup l0242 = # (b l0241 l0241)\\n  dup l0243 = # (b l0242 l0242)\\n  dup l0244 = # (b l0243 l0243)\\n  dup l0245 = # (b l0244 l0244)\\n  dup l0246 = # (b l0245 l0245)\\n  dup l0247 = # (b l0246 l0246)\\n  dup l0248 = # (b l0247 l0247)\\n  dup l0249 = # (b l0248 l0248)\\n  dup l0250 = # (b l0249 l0249)\\n  dup l0251 = # (b l0250 l0250)\\n  dup l0252 = # (b l0251 l0251)\\n  dup l0253 = # (b l0252 l0252)\\n  dup l0254 = # (b l0253 l0253)\\n  dup l0255 = # (b l0254 l0254)\\n  # l0255\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/pbt.fmc?");

/***/ }),

/***/ "../formality/stdlib/stack.fmc":
/*!*************************************!*\
  !*** ../formality/stdlib/stack.fmc ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Pushes 1, 2, 3 to a stack, and pops two values, [3, 2].\\ndef Stack.ex:\\n  let stack      = Stack.new\\n  let stack      = (Stack.push 1 stack)\\n  let stack      = (Stack.push 2 stack)\\n  let stack      = (Stack.push 3 stack)\\n  get [stack, x] = (Stack.pop  0 stack)\\n  get [stack, y] = (Stack.pop  0 stack)\\n  [x, y]\\n\\n// A stack\\n// TODO: annotate type (follow Bits.fmc)\\ndef Stack.push: {x xs} {Push New} (Push x xs)\\ndef Stack.new:         {Push New} New\\n\\n// TODO: annotate type (follow Bits.fmc)\\ndef Stack.head: {default stack}\\n  let case_push = {x rest} x\\n  let case_new  = default\\n  (stack case_push case_new)\\n\\n// TODO: annotate type (follow Bits.fmc)\\ndef Stack.tail: {stack}\\n  let case_push = {x rest} rest\\n  let case_nil  = Nil\\n  (stack case_push case_nil)\\n\\n// TODO: annotate type (follow Bits.fmc)\\ndef Stack.pop: {default stack}\\n  let case_push = {x rest} [rest, x]\\n  let case_new  = [Stack.new, default]\\n  (stack case_push case_new)\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/stack.fmc?");

/***/ }),

/***/ "../formality/stdlib/string.fmc":
/*!**************************************!*\
  !*** ../formality/stdlib/string.fmc ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// TODO: update this whole file\\n\\ndef TEXT: 1954047348\\n\\n// Converts an UTF-8 string into a list of bytes\\ndef to_chars: {str}\\n  {Cons}\\n  dup Cons = Cons\\n  let Cons-non-0 = {c}\\n    cpy c = c\\n    if |c > 0|\\n    then: (Cons c)\\n    else: {x} x\\n  dup f =\\n    let func = {c cs}\\n      cpy c = c\\n      let Cons-c0 = (Cons-non-0 ||c >>  0| & 0xFF|)\\n      let Cons-c1 = (Cons-non-0 ||c >>  8| & 0xFF|)\\n      let Cons-c2 = (Cons-non-0 ||c >> 16| & 0xFF|)\\n      let Cons-c3 = (Cons-non-0 ||c >> 24| & 0xFF|)\\n      (Cons-c0 (Cons-c1 (Cons-c2 (Cons-c3 cs))))\\n    (snd str #func)\\n  # {nil} (f nil)\\n\\n// Converts a list of bytes back to an UTF-8 string\\ndef from_chars: {chars}\\n  let nums =\\n    {Cons}\\n    dup Cons = Cons\\n    dup func =\\n      let loop = {c cont char indx}\\n        cpy indx = indx\\n        cpy char = ||char >> 8| | |c << 24||\\n        cpy done = ||indx % 4| == 3|\\n        let Cons-char =\\n          if done\\n          then: (Cons char)\\n          else: {x}x\\n        let next-char =\\n          if done\\n          then: 0\\n          else: char\\n        (Cons-char (cont next-char |indx + 1|))\\n      (chars #loop)\\n    # {nil} (func {char indx}(Cons char nil) 0 0)\\n  [TEXT, nums]\\n\\n// Converts a String to a utf-8 codepoint list (little endian)\\ndef to_codepoints: {str}\\n  {Cons}\\n  dup Cons = Cons\\n  let loop_aux = {x h}\\n    cpy x = x\\n    (if |x > 0| then:\\n      {h i}\\n      cpy i = i\\n      (if |i == 0| then:\\n        if       |x < 0x80|                then: {h Cons x} (Cons x (h 0))\\n        else: if ||x > 0xc1| * |x < 0xe0|| then: {h Cons x} (h 1 {y} |x + |y << 8||)\\n        else: if ||x > 0xdf| * |x < 0xf0|| then: {h Cons x} (h 2 {y} |x + |y << 8||)\\n        else: if ||x > 0xef| * |x < 0xf5|| then: {h Cons x} (h 3 {y} |x + |y << 8||)\\n        else: {h Cons x} (Cons 0xBDBFEF (h 0)) // Replacement Character: \\\"ï¿½\\\"\\n      else:\\n        if |i == 1| then: {h Cons x} {k} (Cons (k x) (h 0))\\n        else:             {h Cons x} {k} (h |i - 1| {y} (k |x + |y << 8||))\\n      h Cons x)\\n    else: {h} h\\n    h)\\n  let loop = {c h i}\\n    cpy c = c\\n    (loop_aux ||c >>  0| & 0xFF| (loop_aux ||c >>  8| & 0xFF| (loop_aux ||c >> 16| & 0xFF| (loop_aux ||c >> 24| & 0xFF| h))) i)\\n  dup rec = (snd str #loop)\\n  #{Nil} (rec {i} Nil 0)\\n\\n// Converts a utf-8 codepoint list to a String\\ndef from_codepoints: {codepoints} \\n  (from_chars (to_chars [TEXT, codepoints]))\\n\\n// Convert from Unicode Codepoint to UTF-8 Numeric Character Reference\\ndef codepoint_to_ncr: {codepoint}\\n  let conv = {x}\\n    cpy x = x\\n    (if       |x < 0x80|        then:  x\\n     else: if |x < 0xBFE0|      then:  |||x & 0x1F| << 6| | ||x >> 8| & 0x3F||\\n     else: if |x < 0xBFBFF0|    then:  ||||x & 0x0F| << 12| | ||x & 0x3F00| >> 2|| | ||x >> 16| & 0x3F||\\n     else: if |x < 0xBFBF8FF5|  then:  |||||x & 0x07| << 18| | ||x & 0x3F00| << 4|| | ||x & 0x3F0000| >> 10|| | ||x & 0x3F000000| >> 24||\\n     else: 0xBDBFEF) // Replacement Character: \\\"ï¿½\\\"\\n  (conv codepoint)\\n\\n// Convert from UTF-8 Numeric Character Reference to Unicode Codepoint\\ndef ncr_to_codepoint: {ncr}\\n  let conv = {x}\\n    cpy x = x\\n    (if       |x < 0x80|     then:  x\\n     else: if |x < 0x800|    then:  ||||x >> 6| & 0x1F| | 0xC0| + |||x & 0x3F| | 0x80| << 8||\\n     else: if |x < 0x10000|  then:  |||||x & 0x3F| | 0x80| << 16| + ||||x >> 6| & 0x3F| | 0x80| << 8|| + |||x >> 12| & 0x0F| | 0xE0||\\n     else: if |x < 0x110000| then:  ||||||x & 0x3F| | 0x80| << 24| + ||||x >> 6| & 0x3F| | 0x80| << 16|| + ||||x >> 12| & 0x3F| | 0x80| << 8|| + |||x >> 18| & 0x07| | 0xF0||\\n     else: 0xFFFD) // Replacement Character: \\\"ï¿½\\\"\\n  (conv ncr)\\n\\ndef string_concat: {a b}\\n  (from_chars (List.concat (to_chars a) (to_chars b)))\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/string.fmc?");

/***/ }),

/***/ "../formality/stdlib/term.fmc":
/*!************************************!*\
  !*** ../formality/stdlib/term.fmc ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Term\\ndef Lam: {body}      {Lam App Var Put Dup Clo} (Lam body)\\ndef App: {func argm} {Lam App Var Put Dup Clo} (App func argm)\\ndef Var: {indx}      {Lam App Var Put Dup Clo} (Var indx)\\ndef Put: {expr}      {Lam App Var Put Dup Clo} (Put expr)\\ndef Dup: {expr body} {Lam App Var Put Dup Clo} (Dup expr body)\\ndef Clo: {indx}      {Lam App Var Put Dup Clo} (Clo indx)\\n\\ndef Term.rec:\\n  (rec ~6)\\n\\ndef Term.ex:\\n\\n  // Library functions\\n  //dup reduce    = (Term.reduce max_len)\\n  //dup normal    = (Term.normal max_len #reduce)\\n  //dup quote     = (Term.quote max_len)\\n  dup id        = Term.quoted.id\\n\\n  //Example terms\\n  let ID    = (Lam (Var 0))\\n  let TRUE  = (Lam (Lam (Var 0)))\\n  let FALSE = (Lam (Lam (Var 1)))\\n  //let NOT2  = (Lam {b} (App (App b FALSE) TRUE))\\n  //let NOT   = (Lam {b} (Lam {t} (Lam {f} (App (App b f) t))))\\n  //let TWO   = (Lam {s} (Dup s {s} dup s = s # (Lam {z} (App s (App s z)))))\\n  //let NOTS  = (~200 #(App NOT2)) // 310245, and 845032 for NOT2\\n  //let TEST  = (Dup (Put #ID) {x} dup x = x (Put #(Lam {t} (App t x) x)))\\n  let TEST  = (Put #(Put #(Lam (Var 0))))\\n  # (id TEST)\\n\\ndef term: Term.ex\\n\\ndef Term.quoted.id:\\n  let func = {self}\\n    dup self = self\\n    let call = {go term}\\n      dup self = self\\n      let case_lam = {body} {go}\\n        get [go, body] = (go body)\\n        [go, (Lam body)]\\n      let case_app = {func argm} {go}\\n        get [go, func] = (go func)\\n        get [go, argm] = (go argm)\\n        [go, (App func argm)]\\n      let case_var = {indx} {go}\\n        [go, (Var 7)]\\n      let case_put = {expr} {go}\\n        dup expr = expr\\n        [go, (Put #(self expr))]\\n      let case_dup = {expr body} {go}\\n        get [go, expr] = (go expr)\\n        get [go, body] = (go body)\\n        [go, (Dup expr body)]\\n      let case_clo = {indx} {go}\\n        [go, (Clo indx)]\\n      (term case_lam case_app case_var case_put case_dup case_clo go)\\n    let stop = {term}\\n      [{x}x, term]\\n    dup func = (Term.rec #call #stop)\\n    # {term}\\n      (snd (func term))\\n  (func # (func # (func # (func #\\n  (func # (func # (func # (func #\\n  (func # (func # (func # (func #\\n  (func # (func # (func # (func #\\n        # {x}x))))))))))))))))\\n\\n\\n//def Term.id:\\n  //let call = {go term}\\n    //let case_lam = {body} {go}\\n      //get [go, body] = (go body)\\n      //[go, (Lam body)]\\n    //let case_app = {func argm} {go}\\n      //get [go, func] = (go func)\\n      //get [go, argm] = (go argm)\\n      //[go, (App func argm)]\\n    //let case_var = {indx} {go}\\n      //[go, (Var indx)]\\n    //let case_put = {expr} {go}\\n      //dup expr = expr\\n      //[go, (Put #expr)]\\n    //let case_dup = {expr body} {go}\\n      //get [go, expr] = (go expr)\\n      //get [go, body] = (go body)\\n      //[go, (Dup expr body)]\\n    //let case_clo = {indx} {go}\\n      //[go, (Clo indx)]\\n    //(term case_lam case_app case_var case_put case_dup case_clo go)\\n  //let stop = {term}\\n    //[{x}x, term]\\n  //dup func = (Term.rec #call #stop)\\n  //# {term}\\n    //(snd (func term))\\n\\n//def Term.to_string: {mlen}\\n  //let name = {indx}\\n    //let char = (Num.box_byte ||indx % 26| + 97|)\\n    //(List.cons char List.nil)\\n  //let call = {go lams dups term}\\n    //cpy lams = lams\\n    //cpy dups = dups\\n    //let case_lam = {body} {go}\\n      //get [go, body] = (go |lams + 1| dups body)\\n      //let text = List.nil\\n      //let text = (List.concat text (to_chars \\\"{\\\"))\\n      //let text = (List.concat text (name lams))\\n      //let text = (List.concat text (to_chars \\\"}\\\"))\\n      //let text = (List.concat text body)\\n      //[go, text]\\n    //let case_app = {func argm} {go}\\n      //get [go, func] = (go lams dups func)\\n      //get [go, argm] = (go lams dups argm)\\n      //let text = List.nil\\n      //let text = (List.concat text (to_chars \\\"(\\\"))\\n      //let text = (List.concat text func)\\n      //let text = (List.concat text (to_chars \\\" \\\"))\\n      //let text = (List.concat text argm)\\n      //let text = (List.concat text (to_chars \\\")\\\"))\\n      //[go, text]\\n    //let case_var = {indx} {go}\\n      //let text = List.nil\\n      //let text = (List.concat text (name indx))\\n      //[go, text]\\n    //let case_put = {expr} {go}\\n      //get [go, expr] = (go 0 dups expr)\\n      //let text = List.nil\\n      //let text = (List.concat text (to_chars \\\"#\\\"))\\n      //let text = (List.concat text expr)\\n      //[go, text]\\n    //let case_dup = {expr body} {go}\\n      //get [go, expr] = (go lams dups expr)\\n      //get [go, body] = (go lams |dups + 1| body)\\n      //let text = List.nil\\n      //let text = (List.concat text (to_chars \\\"dup {c\\\"))\\n      //let text = (List.concat text (name dups))\\n      //let text = (List.concat text (to_chars \\\"} = \\\"))\\n      //let text = (List.concat text expr)\\n      //let text = (List.concat text (to_chars \\\"; \\\"))\\n      //let text = (List.concat text body)\\n      //[go, text]\\n    //let case_clo = {indx} {go}\\n      //let text = List.nil\\n      //let text = (List.concat text (to_chars \\\"c\\\"))\\n      //let text = (List.concat text (name indx))\\n      //[go, text]\\n    //(term case_lam case_app case_var case_put case_dup case_clo go)\\n  //let stop = {term}\\n    //[{x}x, term]\\n  //dup func = (rec mlen #call #stop)\\n  //# {term}\\n    //(from_chars (snd (func 0 0 term)))\\n\\n\\n//-- A table renaming every `Fin n` by a `Fin m`\\n//Niks : (n m : â) â Set\\n//Niks n m = Fin n â Fin m\\n\\n//-- Increases all renamings in a table, not renaming zero\\n//inc : â {n m} â (niks : Niks n m) â Niks (suc n) (suc m)\\n//inc niks zero    = zero\\n//inc niks (suc i) = suc (niks i)\\n\\n//-- Renames every free var in a `Term n`\\n//rename : â {n m} â (niks : Niks n m) (t : Term n) â Term m\\n//rename niks (var idx)     = var (niks idx)\\n//rename niks typ           = typ\\n//rename niks (all bin bod) = all (rename (inc niks) bin) (rename (inc niks) bod)\\n//rename niks (lam bin bod) = lam (rename (inc niks) bin) (rename (inc niks) bod)\\n//rename niks (app fun arg) = app (rename niks fun) (rename niks arg)\\n\\n//def Term.niks.push: {k niks n}\\n  //cpy n = n\\n  //(if |n == 0|\\n    //then: {niks} [niks, k]\\n    //else: {niks}\\n      //get [niks, n] = (niks |n - 1|)\\n      //[niks, |n + 1|]\\n    //niks)\\n\\n//def Term.nicks.pop: {niks n}\\n  //get [niks, n] = (niks |n + 1|)\\n  //[niks, |n - 1|]\\n\\n//def term:\\n  //let push = Term.niks.push\\n  //let pop  = Term.niks.pop\\n  //let niks = {x} x\\n  //let niks = (push 3 niks)\\n  //let niks = (push 3 niks)\\n  //let niks = (push 3 niks)\\n  //let k = 1\\n  ////get [niks, n] = (niks 0)\\n  ////get [niks, m] = (niks k)\\n  //niks\\n\\n//def Term.rename:\\n  //let ninc = {niks n} cpy n = n (if |n == 0| [0, |(niks |n - 1|) + 1|])\\n  //let ndec = {niks n} |(niks |n + 1|) - 1|\\n  //let ncpy = {niks} [{n} \\n  //let call = {go niks term}\\n    //let case_lam = {body} {go niks}\\n      //get [go  , temp] = (go (ninc niks) body)\\n      //get [niks, body] = temp\\n      //[go, [niks, (Lam body)]]\\n    //let case_app = {func argm} {go niks}\\n      //get [go  , temp] = (go niks func)\\n      //get [niks, func] = temp\\n      //get [go  , temp] = (go niks argm)\\n      //get [niks, argm] = argm\\n      //[go, [niks, (App func argm)]]\\n    //let case_var = {indx} {go niks}\\n      //[go, [niks, (Var (niks idx))]]\\n    \\n  \\n  \\n  \\n\\n//def Term.reduce: {mlen}\\n  //let call = {go term}\\n    //let case_lam = {body} {go}\\n      //[go, (Lam body)]\\n    //let case_app = {func argm} {go}\\n      //let case_lam   = {f_body}        {argm go} (go (f_body argm)) // ([x]a b) ~> [b/x]a\\n      //let case_app   = {f_func f_argm} {argm go} get [go, argm] = (go argm) [go, (App (App f_func f_argm) argm)]\\n      //let case_var   = {f_indx}        {argm go} get [go, argm] = (go argm) [go, (App (Var f_indx) argm)]\\n      //let case_dup   = {f_expr f_body} {argm go} (go (Dup f_expr (App f_body argm))) // ((dup x = a; b) c) ~> dup x = a; (b c)\\n      //let case_put   = {f_expr}        {argm go} get [go, argm] = (go argm) [go, (App (Put f_expr) argm)]\\n      //let case_clo   = {f_indx}        {argm go} get [go, argm] = (go argm) [go, (App (Clo f_indx) argm)]\\n      //get [go, func] = (go func)\\n      //(func case_lam case_app case_var case_dup case_put case_clo argm go)\\n    //let case_var = {indx} {go}\\n      //[go, (Var indx)]\\n    //let case_dup = {expr body} {go}\\n      //let case_lam   = {f_body}        {body go} [go, (Dup (Lam f_body) body)]\\n      //let case_app   = {f_func f_argm} {body go} [go, (Dup (App f_func f_argm) body)]\\n      //let case_var   = {f_indx}        {body go} [go, (Dup (Var f_indx) body)]\\n      //let case_dup   = {f_expr f_body} {body go} (go (Dup f_expr (Dup f_body body))) // [x = [y = a] b] c ~> [y = a] [x = b] c\\n      //let case_put   = {f_expr}        {body go} (go (body f_expr)) // (dup x = #a; b) ~> b[x <- a]\\n      //let case_clo   = {f_indx}        {body go} [go, (Dup (Clo f_indx) body)]\\n      //get [go, expr] = (go expr)\\n      //(expr case_lam case_app case_var case_dup case_put case_clo body go)\\n    //let case_put = {expr} {go}\\n      //[go, (Put expr)]\\n    //let case_clo = {expr} {go}\\n      //[go, (Clo expr)]\\n    //(term case_lam case_app case_var case_dup case_put case_clo go)\\n  //let stop = {term}\\n    //[{x}x, (Var 0)]\\n  //dup func = (rec mlen #call #stop)\\n  //# {term}\\n    //(snd (func term))\\n\\n//def term: Term.ex\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/term.fmc?");

/***/ }),

/***/ "../formality/stdlib/tree.fmc":
/*!************************************!*\
  !*** ../formality/stdlib/tree.fmc ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// TODO: update this file\\n\\ndef Tree.node: {lft rgt}\\n  {Node Leaf}\\n  dup Node = Node\\n  dup Leaf = Leaf\\n  dup lft  = (lft #Node #Leaf)\\n  dup rgt  = (rgt #Node #Leaf)\\n  # (Node lft rgt)\\n\\ndef Tree.leaf: {val}\\n  {Node Leaf}\\n  dup Node = Node\\n  dup Leaf = Leaf\\n  dup val  = val\\n  # (Leaf val)\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/tree.fmc?");

/***/ }),

/***/ "../formality/stdlib/tup.fmc":
/*!***********************************!*\
  !*** ../formality/stdlib/tup.fmc ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Tuples\\n\\n// Creates an example tuple\\ndef Tup.ex:\\n  let tup = Tup.empty\\n  let tup = (Tup.pushfront 2 tup)\\n  let tup = (Tup.pushfront 1 tup)\\n  let tup = (Tup.pushback  3 tup)\\n  let tup = (Tup.pushback  4 tup)\\n  let tup = (Tup.pushfront 0 tup)\\n  (Tup.concat tup (Tup.pushfront 5 Tup.empty))\\n\\n// Let's define tup_rotate_N as the function that receives an N-tuple, and returns\\n// another tuple with the last element on the first position, and the remaining\\n// elements afterwards. I.e., `tup_rotate_4 == {tup T} (tup {a b c d} (T d a b\\n// c))`. To derive `tup_rotate_N` for any `N`, we would need a `next` function that\\n// transforms a tup_rotate `N` into a tup_rotate `N+1`. That is, given:\\n// \\n//   let tup_rotate_4 = {tup T} (tup {a b c d} (T d a b c))\\n//   let tup_rotate_5 = {tup T} (tup {a b c d e} (T e a b c d))\\n// \\n// Then it should follow that `(next tup_rotate_4) == tup_rotate_5`. This can't be\\n// implemented directly, but we can place EDIT points to help us:\\n// \\n//   let editable_4 = {EDIT0} (EDIT0 {EDIT1 a b c d} (EDIT1 {T} (T d a b c)))\\n// \\n// An editable is, as the name says, a tup_rotator that can be edited in two\\n// positions, being more flexible to work with. Notice that `editable_N` can\\n// easily be converted into `tup_rotate_N`:\\n// \\n//   let tup_rotate_N = (editable_N {P0} {tup T} (tup (P0 {t} (t T))))\\n// \\n// Moreover, it can be transformed in an editable `N+1` with: \\n// \\n//   let editable_tup_rotator_SN = {EDIT0} (EDIT0 (editable_tup_rotator_N {P0} {EDIT1 x} (P0 {P1} (EDIT1 {T} (P1 {k} (T x k))))))\\n//\\n// And it can be transformed into an editable `N-1` with:\\n//\\n//   let editable_P0 = {EDIT0} (EDIT0 (editable_N {P0} {EDIT1} (P0 {P1} (EDIT1 {T} (P1 {k a} (T k))) {x}x)))\\n// \\n// With this, we can derive `tup_rotate_N` for any `N`.\\n// \\n// `tup_rotate` is interesting because it fuses with itself, i.e., it's normal form\\n// doesn't increase when applied repeatedly. For example, `(~5 tup_rotate_4)` is\\n// not only equal to `tup_rotate_4` (since rotating a 4-tuple 5 times is the same\\n// as rotating it once), but they have the same normal form, `{a b} (a {c d e\\n// f} (b f c d e))`. This effect is used to implement fast modular exponentiation.\\ndef Tup.rotate_right: {n}\\n  let editable_one  = {EDIT0} (EDIT0 {EDIT1 k} (EDIT1 {T} (T k)))\\n  let editable_succ = {ed} {EDIT0} (EDIT0 (ed {P0} {EDIT1 x} (P0 {P1} (EDIT1 {T} (P1 {k} (T k x))))))\\n  let editable_pred = {ed} {EDIT0} (EDIT0 (ed {P0} {EDIT1} (P0 {P1} (EDIT1 {T} (P1 {k a} (T k))) {x}x)))\\n  let to_tup_rotate = {ed} (ed {P0} {tup T} (tup (P0 {t} (t T))))\\n  dup fold = (n #editable_succ)\\n  # (to_tup_rotate (editable_pred (fold editable_one)))\\n\\n// Teturns a tuple with all numbers from N-1 to 0:\\ndef Tup.rev_range: {n}\\n  dup fold = (n #{state}\\n    get [index, tuple] = state\\n    cpy index          = index\\n    [|index + 1|, {T} (tuple (T index))])\\n  # (snd (fold [0, {T} T]))\\n\\n// Given a `tuple_N`, returns its first element.\\ndef Tup.last: {n}\\n  let editable_one  = {EDIT} (EDIT {x}x)\\n  let editable_succ = {ed} {edit} (ed {get_last} (edit {x} get_last))\\n  let editable_pred = {ed} {edit} (ed {get_last} (edit (get_last {x}x)))\\n  let to_tup_last   = {ed} {T} (T (ed {x}x))\\n  dup fold = (n #editable_succ)\\n  # (to_tup_last (editable_pred (fold editable_one)))\\n\\n// TODO: more tuple functions\\n\\ndef Tup.new: {a b}\\n  {tup} (tup a b)\\n\\ndef Tup.fst: {tup}\\n  (tup {a b}a)\\n\\ndef Tup.snd: {tup}\\n  (tup {a b}b)\\n\\ndef Tup.pushfront: {a tup} {t} (tup (t a))\\ndef Tup.pushback: {a tup} {t} (tup t a)\\ndef Tup.popfront: {tup} {t} (tup {-} t)\\n\\ndef Tup.empty: {t} t\\n\\ndef Tup.concat: {tup1 tup2} {t}\\n  (tup2 (tup1 t))\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/tup.fmc?");

/***/ }),

/***/ "../formality/stdlib/v2.fmc":
/*!**********************************!*\
  !*** ../formality/stdlib/v2.fmc ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def V2.rect.ex: {cons}\\n  dup cons = cons\\n  dup area = (V2.rect ~16 #[4,4] #cons)\\n  # (area [100,100])\\n\\n// Approximates pi\\ndef V2.ex: \\n  let srad = 1200\\n  let form = (V2.circle ~5000 #srad)\\n  let hits = {pos num} |1 + num|\\n  dup circ = (form #hits)\\n  # ||(circ [256,256] 0) * 1000000| / srad|\\n\\n// V2.add\\n// | Receives two 2D vectors and adds them\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   [Num,Num]\\ndef V2.add: {a b}\\n  get [ax,ay] = a\\n  get [bx,by] = b\\n  [|ax + bx|, |ay + by|]\\n\\n// V2.scale\\ndef V2.scale: {a s}\\n  get [ax,ay] = a\\n  [|ax * s|, |ay * s|]\\n\\n// V2.neg\\n// | Negates a 2D vector\\n// : {a : [Num,Num]}\\n//   [Num,Num]\\ndef V2.neg: {a}\\n  get [ax,ay] = a\\n  [|0 - ax|, |0 - ay|]\\n\\n// V2.cpy\\n// | Copies a 2D vector\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   [[Num,Num], [Num,Num]]\\ndef V2.cpy: {a}\\n  get [ax,ay] = a\\n  cpy ax      = ax\\n  cpy ay      = ay\\n  [[ax,ay], [ax,ay]]\\n\\n// V2.sqr_dist\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   Num\\ndef V2.sqr_dist: {a b}\\n  get [ax,ay] = a\\n  get [bx,by] = b\\n  cpy dx = |(Num.dif ax bx) ** 2|\\n  cpy dy = |(Num.dif ay by) ** 2|\\n  |dx + dy|\\n\\n// V2.dist\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   Num\\ndef V2.dist: {a b}\\n  (Num.sqrt (V2.sqr_dist a b))\\n\\n// V2.flat_dist\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   Num\\ndef V2.flat_dist: {a b}\\n  get [ax,ay] = a\\n  get [bx,by] = b\\n  |(Num.dif ax bx) + (Num.dif ay by)|\\n\\n// V2.line\\n// | Up to `max_len`, given a length `len`, a center pos `pos`, and a displacement\\n// | vector `dxy`, returns vectors from `pos`, incrementing by `dxy`, `len` times.\\n// : {max_len : Nat}\\n//   {-P      : Type}\\n//   {cons    : ! {x : [Num,Num]} {xs : P} P}\\n// ! {len     : Num}\\n//   {pos     : [Num,Num]}\\n//   {dxy     : [Num,Num]}\\n//   {nil     : P}\\n//   P\\ndef V2.line: {max_len} {cons}\\n  dup cons = cons\\n  dup fold = (max_len #{list len pos dxy}\\n    get [ax,ay] = pos\\n    get [dx,dy] = dxy\\n    cpy len = len\\n    cpy ax  = ax\\n    cpy ay  = ay\\n    cpy dx  = dx\\n    cpy dy  = dy\\n    (if |len == 0|\\n      then: {list} (list 0 [0,0] [0,0])\\n      else: {list} (cons [ax,ay] (list |len - 1| [|ax + dx|,|ay + dy|] [dx,dy]))\\n      list))\\n  # {len pos dxy nil}\\n    (fold {len pos dxy}nil len pos dxy)\\n\\n// V2.area\\n// : {mlen : Nat}\\n//   {-P   : Type}\\n//   {size : [Num,Num]}\\n//   {cond : ! {x : [Num,Num]} Num}\\n//   {cons : ! {x : [Num,Num]} {xs : P} P}\\n// ! {pos  : [Num,Num]}\\n//   {siz  : [Num,Num]}\\n//   {nil  : P}\\n//   P\\ndef V2.area: {mlen size cond} {cons}\\n  dup cons = cons\\n  dup size = size\\n  dup cond = cond\\n  dup fold = (mlen #{list pos idx}\\n    get [cx,cy] = pos\\n    get [sx,sy] = size\\n    cpy sx = sx\\n    cpy sy = sy\\n    cpy cx = cx\\n    cpy cy = cy\\n    cpy ix = idx\\n    cpy px = ||cx + |ix % sx|| - |sx / 2||\\n    cpy py = ||cy + |ix / sx|| - |sy / 2||\\n    let fn = (if (cond [cx,cy] [sx,sy] [px,py]) [(cons [px,py]),{x}x])\\n    let xs = (list [cx,cy] |ix + 1|)\\n    (fn xs))\\n  # {pos nil}\\n    (fold {pos idx}nil pos 0)\\n\\n// V2.rect\\n// : {mlen : Nat}\\n//   {-P   : Type}\\n//   {size : [Num,Num]}\\n//   {cons : ! {x : [Num,Num]} {xs : P} P}\\n// ! {pos  : [Num,Num]}\\n//   {siz  : [Num,Num]}\\n//   {nil  : P}\\n//   P\\ndef V2.rect: {mlen size}\\n  (V2.area mlen size #{cen siz pos}1)\\n\\n//V2.circle\\n// : {mlen : Nat}\\n//   {-P   : Type}\\n//   {mlen : Nat}\\n//   {srad : Num} -- squared radius\\n//   {cons : ! {pos : [Num,Num]} {state : P} P}\\n// ! {pos  : [Num,Num]}\\n//   {nil  : P}\\n//   P\\ndef V2.circle: {mlen srad cons}\\n  dup cons = cons\\n  dup srad = srad\\n  let isin = {cen siz pos} |(V2.sqr_dist cen pos) < srad|\\n  dup size = #||(Num.sqrt srad) * 2| + 1|\\n  dup area = (V2.area mlen #[size,size] #isin #cons)\\n  # {pos} (area pos)\\n\\n// . . .\\n// . x .\\n// . . .\\ndef V2.circle_a: (V2.circle ~1 #1)\\n\\n// . . . . .\\n// . . x . .\\n// . x x x .\\n// . . x . .\\n// . . . . .\\ndef V2.circle_b: (V2.circle ~9 #2)\\n\\n// . . . . .\\n// . x x x .\\n// . x x x .\\n// . x x x .\\n// . . . . .\\ndef V2.circle_c: (V2.circle ~9 #3)\\n\\n// . . . . . . .\\n// . . . x . . .\\n// . . x x x . .\\n// . x x x x x .\\n// . . x x x . .\\n// . . . x . . .\\n// . . . . . . .\\ndef V2.circle_d: (V2.circle ~25 #5)\\n\\n// . . . . . . .\\n// . . x x x . .\\n// . x x x x x .\\n// . x x x x x .\\n// . x x x x x .\\n// . . x x x . .\\n// . . . . . . .\\ndef V2.circle_e: (V2.circle ~25 #6)\\n\\n// . . . . . . .\\n// . x x x x x .\\n// . x x x x x .\\n// . x x x x x .\\n// . x x x x x .\\n// . x x x x x .\\n// . . . . . . .\\ndef V2.circle_f: (V2.circle ~49 #9)\\n\\n// . . . . . . . . .\\n// . . . . x . . . .\\n// . . x x x x x . .\\n// . . x x x x x . .\\n// . x x x x x x x .\\n// . . x x x x x . .\\n// . . x x x x x . .\\n// . . . . x . . . .\\n// . . . . . . . . .\\ndef V2.circle_g: (V2.circle ~49 #10)\\n\\n// . . . . . . . . .\\n// . . . x x x . . .\\n// . . x x x x x . .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . . x x x x x . .\\n// . . . x x x . . .\\n// . . . . . . . . .\\ndef V2.circle_h: (V2.circle ~49 #11)\\n\\n// . . . . . . . . .\\n// . . x x x x x . .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . . x x x x x . .\\n// . . . . . . . . .\\ndef V2.circle_i: (V2.circle ~49 #14)\\n\\n// . . . . . . . . . . .\\n// . . . . . x . . . . .\\n// . . . x x x x x . . .\\n// . . x x x x x x x . .\\n// . . x x x x x x x . .\\n// . x x x x x x x x x .\\n// . . x x x x x x x . .\\n// . . x x x x x x x . .\\n// . . . x x x x x . . .\\n// . . . . . x . . . . .\\n// . . . . . . . . . . .\\ndef V2.circle_j: (V2.circle ~81 #17)\\n\\n//V2.range\\n// : {mlen : Nat}\\n//   {-P   : Type}\\n//   {rad  : Num} -- radius\\n//   {cons : ! {pos : [Num,Num]} {state : P} P}\\n// ! {pos  : [Num,Num]}\\n//   {nil  : P}\\n//   P\\ndef V2.range: {mlen rad cons}\\n  dup cons = cons\\n  dup rad  = rad\\n  let isin = {cen siz pos} |(V2.flat_dist cen pos) < |rad + 1||\\n  dup size = # ||rad * 2| + 1|\\n  dup area = (V2.area mlen #[size,size] #isin #cons)\\n  # {pos} (area pos)\\n\\ndef V2.range_0: (V2.range ~1 #0)\\ndef V2.range_1: (V2.range ~9 #1)\\ndef V2.range_2: (V2.range ~25 #2)\\ndef V2.range_3: (V2.range ~49 #3)\\ndef V2.range_4: (V2.range ~81 #4)\\ndef V2.range_5: (V2.range ~121 #5)\\ndef V2.range_6: (V2.range ~169 #6)\\n\\n// V2.wave\\n// | Given a list of widths, returns vectors filling a wave from `pos` pointing to `dir`.\\n// : {widths : {-P : Type} {cons : ! {w : Num} {ws : P} P} ! {nil : P} P}\\n//   {-P     : Type}\\n//   {cons   : ! {pos : [Num,Num]} {res : P} P}\\n// ! {pos    : [Num,Num]}\\n//   {dxy    : [Num,Num]}\\n//   {nil    : P}\\n//   P\\ndef V2.wave: {widths} {cons}\\n  dup cons = cons\\n  dup line = (V2.line ~7 #cons)\\n  dup fold = (widths #{w ws pos dxy}\\n    get [ax,ay] = pos\\n    get [dx,dy] = dxy\\n    cpy w  = w\\n    cpy ax = ax\\n    cpy ay = ay\\n    cpy dx = dx\\n    cpy dy = dy\\n    cpy nx = dy\\n    cpy ny = |0 - dx|\\n    let ix = |ax - |nx * |w / 2||| \\n    let iy = |ay - |ny * |w / 2|||\\n    let t  = (ws [|ax + dx|,|ay + dy|] [dx,dy])\\n    (line w [ix,iy] [nx,ny] t))\\n  # {pos dxy nil}\\n    (fold {pos dxy}nil pos dxy)\\n\\n// V2.wave_out\\n// : {widths : {-P : Type} {cons : ! {w : Num} {ws : P} P} ! {nil : P} P}\\n//   {-P     : Type}\\n//   {cons   : ! {pos_dir : [[Num,Num],[Num,Num]]} {res : P} P}\\n// ! {pos    : [Num,Num]}\\n//   {dxy    : [Num,Num]}\\n//   {nil    : P}\\n//   P\\ndef V2.wave_out: {widths} {cons} \\n  dup cons = cons\\n  dup wave = (V2.wave widths #{pos rest dxy}\\n    get [dxy0,dxy1] = (V2.cpy dxy)\\n    (cons [pos,dxy0] (rest dxy1)))\\n  # {pos dxy nil}\\n    get [dxy0,dxy1] = (V2.cpy dxy)\\n    (wave pos dxy0 {dxy}nil dxy1)\\n\\n// V2.wave_in\\n// : {widths : {-P : Type} {cons : ! {w : Num} {ws : P} P} ! {nil : P} P}\\n//   {-P     : Type}\\n//   {cons   : ! {pos_dir : [[Num,Num],[Num,Num]]} {res : P} P}\\n// ! {pos    : [Num,Num]}\\n//   {dxy    : [Num,Num]}\\n//   {nil    : P}\\n//   P\\ndef V2.wave_in: {widths} {cons} \\n  dup cons = cons\\n  dup wave = (V2.wave widths #{pos rest res dxy}\\n    get [dxy0,dxy1] = (V2.cpy dxy)\\n    (rest (cons [pos,dxy0] res) dxy1))\\n  # {pos dxy nil}\\n    get [dxy0,dxy1] = (V2.cpy dxy)\\n    (wave pos dxy0 {res dxy}res nil (V2.neg dxy1))\\n\\ndef v2: V2.ex\\n\");\n\n//# sourceURL=webpack:///../formality/stdlib/v2.fmc?");

/***/ }),

/***/ "./node_modules/formality-core/exports.js":
/*!************************************************!*\
  !*** ./node_modules/formality-core/exports.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var fm = module.exports = {\n  core: __webpack_require__(/*! ./fm-core.js */ \"./node_modules/formality-core/fm-core.js\"),\n  net: __webpack_require__(/*! formality-net */ \"./node_modules/formality-net/fm-net.js\"),\n  to_net: __webpack_require__(/*! ./fm-to-net.js */ \"./node_modules/formality-core/fm-to-net.js\"),\n  to_js: __webpack_require__(/*! ./fm-to-js.js */ \"./node_modules/formality-core/fm-to-js.js\"),\n  norm, check, exec\n};\n\nfunction norm(term, defs, mode = \"OPTIMAL_LAZY\", stats = {}) {\n  switch (mode) {\n    case \"BOXED\":\n      return fm.core.norm(term, defs, false);\n    case \"UNBOXED\":\n      return fm.core.norm(term, defs, true);\n    case \"NATIVE\":\n      return fm.to_js.decompile(fm.to_js.compile(term, defs));\n    case \"OPTIMAL_STRICT\":\n    case \"OPTIMAL_LAZY\":\n      var net = fm.to_net.compile(term, defs);\n      if (stats && stats.input_net === null) {\n        stats.input_net = JSON.parse(JSON.stringify(net));\n      }\n      if (mode === \"OPTIMAL_LAZY\") {\n        var new_stats = net.reduce_lazy(stats || {});\n      } else {\n        var new_stats = net.reduce_strict(stats || {});\n      }\n      if (stats && stats.output_net !== undefined) {\n        stats.output_net = JSON.parse(JSON.stringify(net));\n      }\n      return fm.to_net.decompile(net);\n  }\n}\n\nfunction exec(name, defs, infs, mode = \"OPTIMAL_LAZY\", bipass = false, stats = {}) {\n  if (defs[name] && defs[name][0] === \"Ref\" && !defs[defs[name][1].name]) {\n    name = defs[name][1].name;\n  }\n  if (defs[name]) {\n    return fm.norm(check(defs[name], defs, bipass), defs, mode, stats);\n  } else if (infs[name]) {\n    var data = infs[name];\n    var init = check(data.init, defs, bipass);\n    var step = check(data.step, defs, bipass);\n    var stop = check(data.stop, defs, bipass);\n    var done = check(data.done, defs, bipass);\n    var term = fm.core.norm(init, mode, stats);\n    var cont = term => {\n      var res = fm.norm(fm.core.App(stop, term), defs, mode, stats);\n      if (res[0] === \"Put\") {\n        res = res[1].expr;\n      }\n      return res[0] === \"Num\" && res[1].numb === 0;\n    }\n    while (cont(term)) {\n      term = fm.norm(fm.core.App(step, term), defs, mode, stats);\n      stats.loops += 1;\n    }\n    term = fm.norm(fm.core.App(done, term), defs, mode, stats);\n    return term;\n  } else {\n    throw \"Definition '\" + name + \"' not found.\";\n  }\n}\n\nfunction check(term, defs, bipass = false) {\n  if (!bipass) {\n    try {\n      fm.core.check(term, defs);\n      return term;\n    } catch (e) {\n      console.log(e.toString());\n      process.exit();\n    }\n  } else {\n    return term;\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/formality-core/exports.js?");

/***/ }),

/***/ "./node_modules/formality-core/fm-core.js":
/*!************************************************!*\
  !*** ./node_modules/formality-core/fm-core.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ~~ Formality Core Language ~~\n\n// ::::::::::\n// :: Term ::\n// ::::::::::\n\n// An ESCoC term is an ADT represented by a JSON\nconst Var = (index)                  => [\"Var\", {index}];\nconst Lam = (name, body)             => [\"Lam\", {name, body}];\nconst App = (func, argm)             => [\"App\", {func, argm}];\nconst Put = (expr)                   => [\"Put\", {expr}];\nconst Dup = (name, expr, body)       => [\"Dup\", {name, expr, body}];\nconst Num = (numb)                   => [\"Num\", {numb}];\nconst Op1 = (func, num0, num1)       => [\"Op1\", {func, num0, num1}];\nconst Op2 = (func, num0, num1)       => [\"Op2\", {func, num0, num1}];\nconst Ite = (cond, pair)             => [\"Ite\", {cond, pair}];\nconst Cpy = (name, numb, body)       => [\"Cpy\", {name, numb, body}];\nconst Par = (val0, val1)             => [\"Par\", {val0, val1}];\nconst Fst = (pair)                   => [\"Fst\", {pair}];\nconst Snd = (pair)                   => [\"Snd\", {pair}];\nconst Prj = (nam0, nam1, pair, body) => [\"Prj\", {nam0, nam1, pair, body}];\nconst Ref = (name)                   => [\"Ref\", {name}];\n\n// :::::::::::::\n// :: Parsing ::\n// :::::::::::::\n\n// Converts a string to a term\nconst parse = (code) => {\n  function is_space(char) {\n    return char === \" \" || char === \"\\t\" || char === \"\\n\" || char === \"\\r\";\n  }\n\n  function is_newline(char) {\n    return char === \"\\n\";\n  }\n\n  function is_name_char(char) {\n    return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.-\".indexOf(char) !== -1;\n  }\n\n  function next() {\n    if (is_newline(code[idx])) {\n      row += 1;\n      col = 0;\n    } else {\n      col += 1;\n    }\n    idx += 1;\n  }\n\n  function skip_spaces() {\n    while (idx < code.length && is_space(code[idx])) {\n      next();\n    }\n  }\n\n  function next_char() {\n    skip_spaces();\n    while (code.slice(idx, idx + 2) === \"//\") {\n      while (code[idx] !== \"\\n\" && idx < code.length) {\n        next();\n      }\n      skip_spaces();\n    }\n  }\n\n  function match(string) {\n    next_char();\n    var sliced = code.slice(idx, idx + string.length);\n    if (sliced === string) {\n      for (var i = 0; i < string.length; ++i) {\n        next();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  function parse_exact(string) {\n    if (!match(string)) {\n      var text = \"\";\n      var part = \"\";\n      text += \"Parse error: expected '\" + string + \"' \";\n      text += \"on line \" + (row+1) + \", col \" + col + \", but found '\" + code[idx] + \"' instead. Relevant code:\\n\";\n      for (var ini = idx, il = 0; il < 6 && ini >=          0; --ini) if (code[ini] === \"\\n\") ++il;\n      for (var end = idx, el = 0; el < 6 && end < code.length; ++end) if (code[end] === \"\\n\") ++el;\n      part += code.slice(ini+1, idx) + \"<HERE>\" + code.slice(idx, end);\n      text += part.split(\"\\n\").map((line,i) => (\"    \" + (row-il+i+1)).slice(-4) + \"| \" + line).join(\"\\n\");\n      throw text;\n    }\n  }\n\n  function parse_string(fn = is_name_char) {\n    next_char();\n    var name = \"\";\n    while (idx < code.length && fn(code[idx])) {\n      name = name + code[idx];\n      next();\n    }\n    return name;\n  }\n\n  function parse_term(ctx) {\n    // Application\n    if (match(\"(\")) {\n      var term = parse_term(ctx);\n      while (idx < code.length && !match(\")\")) {\n        var argm = parse_term(ctx);\n        var term = App(term, argm);\n        next_char();\n      }\n      return term;\n    }\n\n    // Lambda\n    else if (match(\"{\")) {\n      var names = [];\n      while (idx < code.length && !match(\"}\")) {\n        names.push(parse_string());\n      }\n      var term = parse_term(ctx.concat(names));\n      for (var i = names.length - 1; i >= 0; --i) {\n        term = Lam(names[i], term);\n      }\n      return term;\n    }\n\n    // Duplication\n    else if (match(\"dup \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var expr = parse_term(ctx);\n      var body = parse_term(ctx.concat([name]));\n      return Dup(name, expr, body);\n    }\n\n    // Put\n    else if (match(\"#\")) {\n      var expr = parse_term(ctx);\n      return Put(expr);\n    }\n\n    // Let\n    else if (match(\"let \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var copy = parse_term(ctx);\n      var body = parse_term(ctx.concat([name]));\n      return subst(body, copy, 0);\n    }\n\n    // Operation\n    else if (match(\"|\")) {\n      var num0 = parse_term(ctx);\n      var func = parse_string(c => !is_space(c));\n      var num1 = parse_term(ctx);\n      var skip = parse_exact(\"|\");\n      return Op2(func, num0, num1);\n    }\n\n    // String\n    else if (match(\"\\\"\")) {\n      // Parses text\n      var text = \"\";\n      while (code[idx] !== \"\\\"\") {\n        text += code[idx];\n        next();\n      }\n      next();\n      return text_to_term(text);\n    }\n\n    // Nat\n    else if (match(\"~\")) {\n      var name = parse_string();\n      var numb = Number(name);\n      return numb_to_term(numb);\n    }\n\n    // If-Then-Else\n    else if (match(\"if \")) {\n      var cond = parse_term(ctx);\n      var pair = parse_term(ctx);\n      return Ite(cond, pair);\n    }\n\n    // Copy\n    else if (match(\"cpy \")) {\n      var name = parse_string();\n      let skip = parse_exact(\"=\");\n      var numb = parse_term(ctx);\n      var body = parse_term(ctx.concat([name]));\n      return Cpy(name, numb, body);\n    }\n\n    // Pair\n    else if (match(\"[\")) {\n      var val0 = parse_term(ctx);\n      var skip = parse_exact(\",\");\n      var val1 = parse_term(ctx);\n      var skip = parse_exact(\"]\");\n      return Par(val0, val1);\n    }\n    \n    // Pair (If-Then-Else sugar)\n    else if (match(\"then:\")) {\n      var val0 = parse_term(ctx);\n      var skip = parse_exact(\"else:\");\n      var val1 = parse_term(ctx);\n      return Par(val0, val1);\n    }\n\n    // First\n    else if (match(\"fst \")) {\n      var pair = parse_term(ctx);\n      return Fst(pair);\n    }\n\n    // Second\n    else if (match(\"snd \")) {\n      var pair = parse_term(ctx);\n      return Snd(pair);\n    }\n\n    // Projection\n    else if (match(\"get \")) {\n      var skip = parse_exact(\"[\");\n      var nam0 = parse_string();\n      var skip = parse_exact(\",\");\n      var nam1 = parse_string();\n      var skip = parse_exact(\"]\");\n      var skip = parse_exact(\"=\");\n      var pair = parse_term(ctx);\n      var body = parse_term(ctx.concat([nam0, nam1]));\n      return Prj(nam0, nam1, pair, body);\n    }\n\n    // Variable / Reference\n    else {\n      var name = parse_string();\n      var numb = Number(name);\n      if (!isNaN(numb)) {\n        return Num(numb >>> 0);\n      }\n      var skip = 0;\n      while (match(\"'\")) {\n        skip += 1;\n      }\n      for (var i = ctx.length - 1; i >= 0; --i) {\n        if (ctx[i] === name) {\n          if (skip === 0) break;\n          else skip -= 1;\n        }\n      }\n      if (i === -1) {\n        return Ref(name);\n      } else {\n        return Var(ctx.length - i - 1);\n      }\n    }\n  }\n\n  var idx = 0;\n  var row = 0;\n  var col = 0;\n  var defs = {};\n  var infs = {};\n  while (idx < code.length) {\n    next_char();\n    if (match(\"inf \")) {\n      var name = parse_string();\n      var skip = parse_exact(\":\");\n      var skip = parse_exact(\"init:\");\n      var init = parse_term([]);\n      var skip = parse_exact(\"step:\");\n      var step = Lam(\"self\", parse_term([\"self\"]));\n      var skip = parse_exact(\"stop:\");\n      var stop = Lam(\"self\", parse_term([\"self\"]));\n      var skip = parse_exact(\"done:\");\n      var done = Lam(\"self\", parse_term([\"self\"]));\n      infs[name] = {init, step, stop, done};\n    } else {\n      var skip = parse_exact(\"def \");\n      var name = parse_string();\n      var skip = parse_exact(\":\");\n      var term = parse_term([]);\n      defs[name] = term;\n    }\n    next_char();\n  }\n\n  return {defs, infs};\n}\n\n// :::::::::::::::::::::\n// :: Stringification ::\n// :::::::::::::::::::::\n\n// Generates a name\nconst gen_name = (n) => {\n  var str = \"\";\n  ++n;\n  while (n > 0) {\n    --n;\n    str += String.fromCharCode(97 + n % 26);\n    n = Math.floor(n / 26);\n  }\n  return str;\n};\n\n// Converts a term to a string\nconst show = ([ctor, args], canon = false, ctx = []) => {\n  switch (ctor) {\n    case \"Var\":\n      return ctx[ctx.length - args.index - 1] || \"^\" + args.index;\n    case \"Lam\":\n      var term = [ctor, args];\n      var numb = null;\n      var names = [];\n      while (term[0] === \"Lam\") {\n        numb = term_to_numb(term);\n        if (numb !== null) {\n          break;\n        } else {\n          names.push(canon ? gen_name(ctx.length) : term[1].name);\n          term = term[1].body;\n        }\n      }\n      var head = names.length > 0 ? \"{\" + names.join(\" \") + \"} \" : \"\";\n      if (numb !== null) {\n        return head + \"~\" + Number(numb);\n      } else {\n        return head + show(term, canon, ctx.concat(names))\n      }\n    case \"App\":\n      var text = \")\";\n      var term = [ctor, args];\n      while (term[0] === \"App\") {\n        text = \" \" + show(term[1].argm, canon, ctx) + text;\n        term = term[1].func;\n      }\n      return \"(\" + show(term, canon, ctx) + text;\n    case \"Put\":\n      var expr = show(args.expr, canon, ctx);\n      return \"#\" + expr;\n    case \"Dup\":\n      var name = args.name;\n      var expr = show(args.expr, canon, ctx);\n      var body = show(args.body, canon, ctx.concat([name]));\n      return \"(dup \" + name + \" = \" + expr + \" \" + body + \")\";\n    case \"Num\":\n      return args.numb.toString();\n    case \"Op1\":\n    case \"Op2\":\n      var func = args.func;\n      var num0 = show(args.num0, canon, ctx);\n      var num1 = show(args.num1, canon, ctx);\n      return \"|\" + num0 + \" \" + func + \" \" + num1 + \"|\";\n    case \"Ite\":\n      var cond = show(args.cond, canon, ctx);\n      var pair = show(args.pair, canon, ctx);\n      return \"(if \" + cond + \" \" + pair + \")\";\n    case \"Cpy\":\n      var name = args.name;\n      var numb = show(args.numb, canon, ctx);\n      var body = show(args.body, canon, ctx.concat([name]));\n      return \"(cpy \" + name + \" = \" + numb + \" \" + body + \")\";\n    case \"Par\":\n      var text = term_to_text([ctor, args]);\n      if (text !== null) {\n        return \"\\\"\" + text + \"\\\"\";\n      } else {\n        var val0 = show(args.val0, canon, ctx);\n        var val1 = show(args.val1, canon, ctx);\n        return \"[\" + val0 + \",\" + val1 + \"]\";\n      }\n    case \"Fst\":\n      var pair = show(args.pair, canon, ctx);\n      return \"(fst \" + pair + \")\";\n    case \"Snd\":\n      var pair = show(args.pair, canon, ctx);\n      return \"(snd \" + pair + \")\";\n    case \"Prj\":\n      var nam0 = args.nam0;\n      var nam1 = args.nam1;\n      var pair = show(args.pair, canon, ctx);\n      var body = show(args.body, canon, ctx.concat([nam0, nam1]));\n      return \"(get [\" + nam0 + \",\" + nam1 + \"] = \" + pair + \" \" + body + \")\";\n    case \"Ref\":\n      return args.name;\n  }\n}\n\n// ::::::::::::::::::\n// :: Substitution ::\n// ::::::::::::::::::\n\n// Shifts a term\nconst shift = ([ctor, term], inc, depth) => {\n  switch (ctor) {\n    case \"Var\":\n      return Var(term.index < depth ? term.index : term.index + inc);\n    case \"Lam\":\n      var name = term.name;\n      var body = shift(term.body, inc, depth + 1);\n      return Lam(name, body);\n    case \"App\":\n      var func = shift(term.func, inc, depth);\n      var argm = shift(term.argm, inc, depth);\n      return App(func, argm);\n    case \"Put\":\n      var expr = shift(term.expr, inc, depth);\n      return Put(expr);\n    case \"Dup\":\n      var name = term.name;\n      var expr = shift(term.expr, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return Dup(name, expr, body);\n    case \"Num\":\n      var numb = term.numb;\n      return Num(numb);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = shift(term.num0, inc, depth);\n      var num1 = shift(term.num1, inc, depth);\n      return Op2(func, num0, num1);\n    case \"Ite\":\n      var cond = shift(term.cond, inc, depth);\n      var pair = shift(term.pair, inc, depth);\n      return Ite(cond, pair);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = shift(term.numb, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return Cpy(name, numb, body);\n    case \"Par\":\n      var val0 = shift(term.val0, inc, depth);\n      var val1 = shift(term.val1, inc, depth);\n      return Par(val0, val1);\n    case \"Fst\":\n      var pair = shift(term.pair, inc, depth);\n      return Fst(pair);\n    case \"Snd\":\n      var pair = shift(term.pair, inc, depth);\n      return Snd(pair);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = shift(term.pair, inc, depth);\n      var body = shift(term.body, inc, depth + 2);\n      return Prj(nam0, nam1, pair, body);\n    case \"Ref\":\n      return Ref(term.name);\n  }\n}\n\n// Substitution\nconst subst = ([ctor, term], val, depth) => {\n  switch (ctor) {\n    case \"Var\":\n      return depth === term.index ? val : Var(term.index - (term.index > depth ? 1 : 0));\n    case \"Lam\":\n      var name = term.name;\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Lam(name, body);\n    case \"App\":\n      var func = subst(term.func, val, depth);\n      var argm = subst(term.argm, val, depth);\n      return App(func, argm);\n    case \"Put\":\n      var expr = subst(term.expr, val, depth);\n      return Put(expr);\n    case \"Dup\": \n      var name = term.name;\n      var expr = subst(term.expr, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Dup(name, expr, body);\n    case \"Num\":\n      var numb = term.numb;\n      return Num(numb);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = subst(term.num0, val, depth);\n      var num1 = subst(term.num1, val, depth);\n      return Op2(func, num0, num1);\n    case \"Ite\":\n      var cond = subst(term.cond, val, depth);\n      var pair = subst(term.pair, val, depth);\n      return Ite(cond, pair);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = subst(term.numb, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Cpy(name, numb, body);\n    case \"Par\":\n      var val0 = subst(term.val0, val, depth);\n      var val1 = subst(term.val1, val, depth);\n      return Par(val0, val1);\n    case \"Fst\":\n      var pair = subst(term.pair, val, depth);\n      return Fst(pair);\n    case \"Snd\":\n      var pair = subst(term.pair, val, depth);\n      return Snd(pair);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = subst(term.pair, val, depth);\n      var body = subst(term.body, val && shift(val, 2, 0), depth + 2);\n      return Prj(nam0, nam1, pair, body);\n    case \"Ref\":\n      var name = term.name;\n      return Ref(name);\n  }\n}\n\n// ::::::::::::::::::::\n// :: Stratification ::\n// ::::::::::::::::::::\n\n// How many times a variable was used in computational positions\nconst uses = ([ctor, term], depth = 0) => {\n  switch (ctor) {\n    case \"Var\": return term.index === depth ? 1 : 0;\n    case \"Lam\": return uses(term.body, depth + 1);\n    case \"App\": return uses(term.func, depth) + uses(term.argm, depth);\n    case \"Put\": return uses(term.expr, depth);\n    case \"Dup\": return uses(term.expr, depth) + uses(term.body, depth + 1);\n    case \"Num\": return 0;\n    case \"Op1\": return uses(term.num0, depth) + uses(term.num1, depth);\n    case \"Op2\": return uses(term.num0, depth) + uses(term.num1, depth);\n    case \"Ite\": return uses(term.cond, depth) + uses(term.pair, depth);\n    case \"Cpy\": return uses(term.numb, depth) + uses(term.body, depth + 1);\n    case \"Par\": return uses(term.val0, depth) + uses(term.val1, depth);\n    case \"Fst\": return uses(term.pair, depth);\n    case \"Snd\": return uses(term.pair, depth);\n    case \"Prj\": return uses(term.pair, depth) + uses(term.body, depth + 2);\n    case \"Ref\": return 0;\n  }\n}\n\n// Checks if variable only occurs at a specific relative level\nconst is_at_level = ([ctor, term], at_level, depth = 0, level = 0) => {\n  switch (ctor) {\n    case \"Var\": return term.index !== depth || level === at_level;\n    case \"Lam\": return is_at_level(term.body, at_level, depth + 1, level);\n    case \"App\": return is_at_level(term.func, at_level, depth, level) && is_at_level(term.argm, at_level, depth, level);\n    case \"Put\": return is_at_level(term.expr, at_level, depth, level + 1);\n    case \"Dup\": return is_at_level(term.expr, at_level, depth, level) && is_at_level(term.body, at_level, depth + 1, level);\n    case \"Num\": return true;\n    case \"Op1\": return is_at_level(term.num0, at_level, depth, level) && is_at_level(term.num1, at_level, depth, level);\n    case \"Op2\": return is_at_level(term.num0, at_level, depth, level) && is_at_level(term.num1, at_level, depth, level);\n    case \"Ite\": return is_at_level(term.cond, at_level, depth, level) && is_at_level(term.pair, at_level, depth, level);\n    case \"Cpy\": return is_at_level(term.numb, at_level, depth, level) && is_at_level(term.body, at_level, depth + 1, level);\n    case \"Par\": return is_at_level(term.val0, at_level, depth, level) && is_at_level(term.val1, at_level, depth, level);\n    case \"Fst\": return is_at_level(term.pair, at_level, depth, level);\n    case \"Snd\": return is_at_level(term.pair, at_level, depth, level);\n    case \"Prj\": return is_at_level(term.pair, at_level, depth, level) && is_at_level(term.body, at_level, depth + 2, level);\n    case \"Pri\": return is_at_level(term.argm, at_level, depth, level);\n    case \"Ref\": return true;\n  }\n}\n\n// Checks if a term is stratified\nconst check = ([ctor, term], defs = {}, ctx = []) => {\n  switch (ctor) {\n    case \"Lam\": \n      if (uses(term.body) > 1) {\n        throw \"[ERROR]\\nLambda variable `\" + term.name + \"` used more than once in:\\n\" + show([ctor, term], false, ctx);\n      }\n      if (!is_at_level(term.body, 0)) {\n        throw \"[ERROR]\\nLambda variable `\" + term.name + \"` used inside a box in:\\n\" + show([ctor, term], false, ctx);\n      }\n      check(term.body, defs, ctx.concat([term.name]));\n      break;\n    case \"App\":\n      check(term.func, defs, ctx);\n      check(term.argm, defs, ctx);\n      break;\n    case \"Put\":\n      check(term.expr, defs, ctx);\n      break;\n    case \"Dup\":\n      if (!is_at_level(term.body, 1)) {\n        throw \"[ERROR]\\nDuplication variable `\" + term.name + \"` must always have exactly 1 enclosing box on the body of:\\n\" + show([ctor, term], false, ctx);\n      }\n      check(term.expr, defs, ctx);\n      check(term.body, defs, ctx.concat([term.name]));\n      break;\n    case \"Op1\":\n    case \"Op2\":\n      check(term.num0, defs, ctx);\n      check(term.num1, defs, ctx);\n      break;\n    case \"Ite\":\n      check(term.cond, defs, ctx);\n      check(term.pair, defs, ctx);\n      break;\n    case \"Cpy\":\n      check(term.numb, defs, ctx);\n      check(term.body, defs, ctx.concat([term.name]));\n      break;\n    case \"Par\":\n      check(term.val0, defs, ctx);\n      check(term.val1, defs, ctx);\n      break;\n    case \"Fst\":\n      check(term.pair, defs, ctx);\n      break;\n    case \"Snd\":\n      check(term.pair, defs, ctx);\n      break;\n    case \"Prj\":\n      var uses0 = uses(term.body, 1);\n      var uses1 = uses(term.body, 0);\n      var isat0 = is_at_level(term.body, 0, 1);\n      var isat1 = is_at_level(term.body, 0, 0);\n      if (uses0 > 1 || uses1 > 1) {\n        throw \"[ERROR]\\nProjection variable `\" + (uses0 > 1 ? term.nam0 : term.nam1) + \"` used more than once in:\\n\" + show([ctor, term], false, ctx);\n      }\n      if (!isat0 || !isat1) {\n        throw \"[ERROR]\\nProjection variable `\" + (!isat0 ? term.nam0 : term.nam1) + \"` used inside a box in:\\n\" + show([ctor, term], false, ctx);\n      }\n      check(term.pair, defs, ctx);\n      check(term.body, defs, ctx.concat([term.nam0, term.nam1]));\n      break;\n    case \"Ref\":\n      if (!defs[term.name]) {\n        throw \"[ERROR]\\nUndefined reference: \" + term.name;\n      } else {\n        check(defs[term.name], defs, ctx);\n        break;\n      }\n  }\n}\n\n// ::::::::::::::::\n// :: Evaluation ::\n// ::::::::::::::::\n\n// Reduces a term to normal form or head normal form\nconst norm = (term, defs = {}, to_lam = false) => {\n  var [ctor, term] = term;\n  const apply = (func, argm) => {\n    var func = norm(func, defs, to_lam);\n    // ([x]a b) ~> [b/x]a\n    if (func[0] === \"Lam\") {\n      return norm(subst(func[1].body, argm, 0), defs, to_lam);\n    // ([x = a] b c) ~> [x = a] (b c)\n    } else if (func[0] === \"Dup\") {\n      return norm(Dup(func[1].name, func[1].expr, App(func[1].body, shift(argm, 1, 0))), defs, to_lam);\n    // (|a b) ~> â¥\n    } else if (func[0] === \"Put\") {\n      throw \"[RUNTIME-ERROR]\\nCan't apply a boxed value.\";\n    } else {\n      return App(norm(func, defs, to_lam), norm(argm, defs, to_lam));\n    }\n  }\n  const duplicate = (name, expr, body) => {\n    var expr = norm(expr, defs, to_lam);\n    // [x = |a] b ~> [a/x]b\n    if (expr[0] === \"Put\") {\n      return norm(subst(body, expr[1].expr, 0), defs, to_lam);\n    // [x = [y = a] b] c ~> [y = a] [x = b] c\n    } else if (expr[0] === \"Dup\") {\n      return norm(Dup(expr[1].name, expr[1].expr, Dup(name, expr[1].body, shift(body, 1, 1))), defs, to_lam); \n    // [x = [y] b] c ~> â¥\n    } else if (expr[0] === \"Lam\") {\n      throw \"[RUNTIME-ERROR]\\nCan't duplicate a lambda.\";\n    } else {\n      return Dup(name, expr, norm(body, defs, to_lam));\n    }\n  }\n  const dereference = (name) => {\n    if (defs[name]) {\n      return norm(defs[name], defs, to_lam);\n    } else {\n      return Ref(name);\n    }\n  }\n  const op1 = (func, num0, num1) => {\n    var num0 = norm(num0, defs, to_lam);\n    if (num0[0] === \"Num\") {\n      switch (func) {\n        case \"+\"  : return Num((num0[1].numb + num1[1].numb) >>> 0);\n        case \"-\"  : return Num((num0[1].numb - num1[1].numb) >>> 0);\n        case \"*\"  : return Num((num0[1].numb * num1[1].numb) >>> 0);\n        case \"/\"  : return Num((num0[1].numb / num1[1].numb) >>> 0);\n        case \"%\"  : return Num((num0[1].numb % num1[1].numb) >>> 0);\n        case \"**\" : return Num((num0[1].numb ** num1[1].numb) >>> 0);\n        case \"^^\" : return Num((num0[1].numb ** (num1[1].numb / (2 ** 32))) >>> 0);\n        case \"&\"  : return Num((num0[1].numb & num1[1].numb) >>> 0);\n        case \"|\"  : return Num((num0[1].numb | num1[1].numb) >>> 0);\n        case \"^\"  : return Num((num0[1].numb ^ num1[1].numb) >>> 0);\n        case \"~\"  : return Num((~ num1[1].numb) >>> 0);\n        case \">>\" : return Num((num0[1].numb >>> num1[1].numb) >>> 0);\n        case \"<<\" : return Num((num0[1].numb << num1[1].numb) >>> 0);\n        case \">\"  : return Num((num0[1].numb > num1[1].numb ? 1 : 0) >>> 0);\n        case \"<\"  : return Num((num0[1].numb < num1[1].numb ? 1 : 0) >>> 0);\n        case \"==\" : return Num((num0[1].numb === num1[1].numb ? 1 : 0) >>> 0);\n        default   : throw \"[RUNTIME-ERROR]\\nUnknown primitive: \" + func + \".\";\n      }\n    } else {\n      return Op1(func, num0, norm(num1, defs, to_lam));\n    }\n  }\n  const op2 = (func, num0, num1) => {\n    var num1 = norm(num1, defs, to_lam);\n    if (num1[0] === \"Num\") {\n      return norm(Op1(func, num0, num1), defs, to_lam);\n    } else {\n      return Op2(func, norm(num0, defs, to_lam), num1);\n    }\n  }\n  const if_then_else = (cond, pair) => {\n    var cond = norm(cond, defs, to_lam);\n    if (cond[0] === \"Num\") {\n      return norm(cond[1].numb > 0 ? Fst(pair) : Snd(pair), defs, to_lam);\n    } else {\n      return Ite(cond, norm(pair, defs, to_lam));\n    }\n  }\n  const copy = (name, numb, body) => {\n    var numb = norm(numb, defs, to_lam);\n    if (numb[0] === \"Num\") {\n      return norm(subst(body, numb, 0), defs, to_lam);\n    } else {\n      return Cpy(name, numb, norm(body, defs, to_lam));\n    }\n  }\n  const first = (pair) => {\n    var pair = norm(pair, defs, to_lam);\n    if (pair[0] === \"Par\") {\n      return norm(pair[1].val0, defs, to_lam);\n    } else {\n      return Fst(pair);\n    }\n  }\n  const second = (pair) => {\n    var pair = norm(pair, defs, to_lam);\n    if (pair[0] === \"Par\") {\n      return norm(pair[1].val1, defs, to_lam);\n    } else {\n      return Snd(pair);\n    }\n  }\n  const case_of = (nam0, nam1, pair, body) => {\n    var pair = norm(pair, defs, to_lam);\n    if (pair[0] === \"Par\") {\n      return norm(subst(subst(body, shift(pair[1].val0, 1, 0), 1), pair[1].val1, 0), defs, to_lam);\n    } else {\n      return Prj(nam0, nam1, pair, norm(body, defs, to_lam));\n    }\n  }\n  if (to_lam && ctor === \"Put\") {\n    return norm(term.expr, defs, to_lam);\n  } else if (to_lam && ctor === \"Dup\") {\n    return norm(subst(term.body, term.expr, 0), defs, to_lam)\n  } else if (to_lam && ctor === \"Prj\") {\n    return norm(subst(subst(term.body, Fst(shift(term.pair, 1, 0)), 1), Snd(term.pair), 0), defs, to_lam);\n  } else if (to_lam && ctor === \"Cpy\") {\n    return norm(subst(term.body, term.numb, 0), defs, to_lam)\n  } else {\n    switch (ctor) {\n      case \"Var\": return Var(term.index);\n      case \"Lam\": return Lam(term.name, norm(term.body, defs, to_lam)); \n      case \"App\": return apply(term.func, term.argm);\n      case \"Put\": return Put(norm(term.expr, defs, to_lam));\n      case \"Dup\": return duplicate(term.name, term.expr, term.body);\n      case \"Num\": return Num(term.numb);\n      case \"Op1\": return op1(term.func, term.num0, term.num1);\n      case \"Op2\": return op2(term.func, term.num0, term.num1);\n      case \"Ite\": return if_then_else(term.cond, term.pair);\n      case \"Cpy\": return copy(term.name, term.numb, term.body);\n      case \"Par\": return Par(norm(term.val0, defs, to_lam), norm(term.val1, defs, to_lam));\n      case \"Fst\": return first(term.pair);\n      case \"Snd\": return second(term.pair);\n      case \"Prj\": return case_of(term.nam0, term.nam1, term.pair, term.body);\n      case \"Ref\": return dereference(term.name);\n    }\n  }\n}\n\n// ::::::::::::::\n// :: Equality ::\n// ::::::::::::::\n\n// Checks if two terms are equal\nconst equal = ([a_ctor, a_term], [b_ctor, b_term]) => {\n  switch (a_ctor + \"-\" + b_ctor) {\n    case \"var-var\": return a_term.index === b_term.index;\n    case \"lam-lam\": return equal(a_term.body, b_term.body);\n    case \"app-app\": return equal(a_term.func, b_term.func) && equal(a_term.argm, b_term.argm);\n    case \"put-put\": return equal(a_term.expr, b_term.expr);\n    case \"dup-dup\": return equal(a_term.expr, b_term.expr) && equal(a_term.body, b_term.body);\n    case \"ref-ref\": return a_term.name === b_term.name;\n    case \"num-num\": return a_term.numb === b_term.numb;\n    case \"op1-op1\": return a_term.func === b_term.func && equal(a_term.num0, b_term.num0) && a_term.num1 === a_term.num1;\n    case \"op2-op2\": return a_term.func === b_term.func && equal(a_term.num0, b_term.num0) && equal(a_term.num1, b_term.num1);\n    case \"ite-ite\": return equal(a_term.cond, b_term.cond) && equal(a_term.pair, b_term.pair);\n    case \"cpy-cpy\": return equal(a_term.numb, b_term.numb) && equal(a_term.body, b_term.body);\n    case \"par-par\": return equal(a_term.val0, b_term.val0) && equal(a_term.val1, b_term.val1);\n    case \"fst-fst\": return equal(a_term.pair, b_term.pair);\n    case \"snd-snd\": return equal(a_term.pair, b_term.pair);\n    case \"cas-cas\": return equal(a_term.pair, b_term.pair) && equal(a_term.body, b_term.body);\n    default: return false;\n  }\n}\n\n// :::::::::::::::::::\n// :: Syntax Sugars ::\n// :::::::::::::::::::\n\n// Converts an utf-8 string to a Î»-encoded term\nconst text_to_term = (text) => {\n  // Converts UTF-8 to bytes\n  var bytes = [].slice.call(new TextEncoder(\"utf-8\").encode(text), 0);\n\n  // Converts bytes to uints\n  while (bytes.length % 4 !== 0) {\n    bytes.push(0);\n  }\n  var nums = new Uint32Array(new Uint8Array(bytes).buffer);\n\n  // Converts uints to C-List of nums\n  var term = Var(0);\n  for (var i = nums.length - 1; i >= 0; --i) {\n    term = App(App(Var(1), Num(nums[i])), term);\n  }\n  term = Par(Num(0x74786574), Lam(\"c\", Dup(\"c\", Var(0), Put(Lam(\"n\", term)))));\n  return term;\n}\n\n// Converts a Î»-encoded term to a string, if possible\nconst term_to_text = (term) => {\n  try {\n    if (term[1].val0[1].numb === 0x74786574) {\n      try {\n        term = term[1].val1[1].body[1].body[1].expr[1].body;\n      } catch(e) {\n        term = term[1].val1[1].body[1].body;\n      }\n      var nums = [];\n      while (term[0] !== \"Var\") {\n        if (term[1].func[1].func[1].index !== 1) {\n          return null;\n        }\n        nums.push(term[1].func[1].argm[1].numb);\n        term = term[1].argm;\n      }\n      if (term[1].index !== 0) {\n        return null;\n      }\n      return new TextDecoder(\"utf-8\").decode(new Uint8Array(new Uint32Array(nums).buffer));\n    } else {\n      return null;\n    }\n  } catch (e) {\n    return null;\n  }\n}\n\n// Converts a number to a Î»-encoded nat for repeated application (bounded for-loop)\nconst numb_to_term = (numb) => {\n  var term = Var(0);\n  var log2 = Math.floor(Math.log(numb) / Math.log(2));\n  for (var i = 0; i < log2 + 1; ++i) {\n    term = (numb >>> (log2 - i)) & 1 ? App(Var(i + 1), term) : term;\n  }\n  term = Put(Lam(\"x\", term));\n  for (var i = 0; i < log2; ++i) {\n    term = Dup(\"s\" + (log2 - i), Put(Lam(\"x\", App(Var(1), App(Var(1), Var(0))))), term);\n  }\n  term = Lam(\"s\", Dup(\"s0\", Var(0), term));\n  return term;\n}\n\n// Converts a Î»-encoded nat to a number, if possible\nconst term_to_numb = (term) => {\n  try {\n    try {\n      term = term[1].body[1].body[1].expr[1].body;\n    } catch(e) {\n      term = term[1].body[1].body;\n    }\n    var count = 0;\n    while (term[0] !== \"Var\") {\n      if (term[1].func[1].index !== 1) {\n        return null;\n      }\n      count++;\n      term = term[1].argm;\n    }\n    if (term[1].index !== 0) {\n      return null;\n    }\n    return count;\n  } catch (e) {\n    return null;\n  }\n}\n\nmodule.exports = {\n  Var, Ref, Lam, App, Put,\n  Dup, Num, Op1, Op2, Ite,\n  Cpy, Par, Fst, Snd, Prj,\n  gen_name,\n  parse,\n  show,\n  check,\n  norm,\n  equal\n};\n\n\n//# sourceURL=webpack:///./node_modules/formality-core/fm-core.js?");

/***/ }),

/***/ "./node_modules/formality-core/fm-to-js.js":
/*!*************************************************!*\
  !*** ./node_modules/formality-core/fm-to-js.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const fmc = __webpack_require__(/*! ./fm-core.js */ \"./node_modules/formality-core/fm-core.js\");\n\n// Converts a Formality-Core Term to a native JavaScript function\nconst compile = ([ctor, term], defs, vars) => {\n  switch (ctor) {\n    case \"Var\":\n      for (var i = 0; i < term.index; ++i) {\n        vars = vars[1];\n      }\n      return vars[0];\n    case \"Lam\":\n      return x => compile(term.body, defs, [x, vars]);\n    case \"App\":\n      var func = compile(term.func, defs, vars);\n      var argm = compile(term.argm, defs, vars);\n      return func(argm);\n    case \"Put\":\n      return compile(term.expr, defs, vars);\n    case \"Dup\": \n      var expr = compile(term.expr, defs, vars);\n      var body = x => compile(term.body, defs, [x,vars]);\n      return body(expr);\n    case \"Num\":\n      return term.numb;\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = compile(term.num0, defs, vars);\n      var num1 = compile(term.num1, defs, vars);\n      switch (func) {\n        case \"+\"  : return (num0 + num1) >>> 0;\n        case \"-\"  : return (num0 - num1) >>> 0;\n        case \"*\"  : return (num0 * num1) >>> 0;\n        case \"/\"  : return (num0 / num1) >>> 0;\n        case \"%\"  : return (num0 % num1) >>> 0;\n        case \"**\" : return (num0 ** num1) >>> 0;\n        case \"^^\" : return (num0 ** (num1 / (2 ** 32))) >>> 0;\n        case \"&\"  : return (num0 & num1) >>> 0;\n        case \"|\"  : return (num0 | num1) >>> 0;\n        case \"^\"  : return (num0 ^ num1) >>> 0;\n        case \"~\"  : return (~ num1) >>> 0;\n        case \">>\" : return (num0 >>> num1) >>> 0;\n        case \"<<\" : return (num0 << num1) >>> 0;\n        case \">\"  : return (num0 > num1) >>> 0;\n        case \"<\"  : return (num0 < num1) >>> 0;\n        case \"==\" : return (num0 === num1) >>> 0;\n      }\n    case \"Ite\":\n      var cond = compile(term.cond, defs, vars);\n      var pair = compile(term.pair, defs, vars);\n      return cond ? pair[0] : pair[1];\n    case \"Cpy\":\n      var numb = compile(term.numb, defs, vars);\n      var body = x => compile(term.body, defs, [x,vars]);\n      return body(numb);\n    case \"Par\":\n      var val0 = compile(term.val0, defs, vars);\n      var val1 = compile(term.val1, defs, vars);\n      return [val0, val1];\n    case \"Fst\":\n      var pair = compile(term.pair, defs, vars);\n      return pair[0];\n    case \"Snd\":\n      var pair = compile(term.pair, defs, vars);\n      return pair[1];\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = compile(term.pair, defs, vars);\n      var body = (x,y) => compile(term.body, defs, [y,[x,vars]]);\n      return body(pair[0], pair[1]);\n    case \"Ref\":\n      return compile(defs[term.name], defs, vars);\n  }\n};\n\n// Converts a native JavaScript function back to a Formality-Core term\nconst decompile = (func) => {\n  return (function go(term, depth) {\n    function APP(variable) {\n      return function FMC_DECOMPILE_GET(arg){\n        if (arg === null) {\n          return variable;\n        } else {\n          return APP(d => fmc.App(variable(d), go(arg, d)));\n        }\n      };\n    };\n    function VAR(d) {\n      return fmc.Var(d - 1 - depth);\n    };\n    if (typeof term === \"function\" && term.name === \"FMC_DECOMPILE_GET\") {\n      return term(null)(depth);\n    } else if (typeof term === \"object\") {\n      var val0 = go(term[0], depth);\n      var val1 = go(term[1], depth);\n      return fmc.Par(val0, val1);\n    } else if (typeof term === \"number\") {\n      return fmc.Num(term);\n    } else if (typeof term === \"function\") {\n      var body = go(term(APP(VAR)), depth + 1);\n      return fmc.Lam(fmc.gen_name(depth), body);\n    } else if (typeof term === \"string\") {\n      throw \"[ERROR]\\nThis native JS function can't be decompiled to FMC:\\n\\n\"\n        + func.toString()\n        + \"\\n\\nIt possibly uses numeric operators on free variables, which can't be decompiled yet.\";\n    } else {\n      return term;\n    }\n  })(func, 0);\n};\n\nmodule.exports = {compile, decompile};\n\n\n//# sourceURL=webpack:///./node_modules/formality-core/fm-to-js.js?");

/***/ }),

/***/ "./node_modules/formality-core/fm-to-net.js":
/*!**************************************************!*\
  !*** ./node_modules/formality-core/fm-to-net.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ~~ Compiles Formality Core to Formality Net ~~\n\nconst {Var, App, Lam, Num, Op1, Op2, Ite, Par, Fst, Snd, gen_name} = __webpack_require__(/*! ./fm-core.js */ \"./node_modules/formality-core/fm-core.js\");\nconst {Net, Pointer, Numeric, addr_of, slot_of, type_of, numb_of, NOD, OP1, OP2, NUM, ITE, PTR, FOR} = __webpack_require__(/*! formality-net */ \"./node_modules/formality-net/fm-net.js\");\n\nconst op_kind = {\n   0 : \"+\"  , \"+\"  : 0, \n   1 : \"-\"  , \"-\"  : 1, \n   2 : \"*\"  , \"*\"  : 2, \n   3 : \"/\"  , \"/\"  : 3, \n   4 : \"%\"  , \"%\"  : 4,\n   5 : \"**\" , \"**\" : 5,\n   6 : \"^^\" , \"^^\" : 6,\n   7 : \"&\"  , \"&\"  : 7,\n   8 : \"|\"  , \"|\"  : 8,\n   9 : \"^\"  , \"^\"  : 9,\n  10 : \"~\"  , \"~\"  : 10,\n  11 : \">>\" , \">>\" : 11,\n  12 : \"<<\" , \"<<\" : 12,\n  13 : \">\"  , \">\"  : 13,\n  14 : \"<\"  , \"<\"  : 14,\n  15 : \"==\" , \"==\"  : 15,\n};\n\nconst compile = (term, defs = {}) => {\n  const build_net = (term, net, var_ptrs, level) => {\n    const get_var = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return ptrn;\n      } else {\n        if (net.enter_port(ptrn) === ptrn) {\n          return ptrn;\n        } else {\n          var dups_ptrn = net.enter_port(ptrn);\n          var dup_addr = net.alloc_node(NOD, level_of[ptrn] + 1);\n          net.link_ports(Pointer(dup_addr, 0), ptrn);\n          net.link_ports(Pointer(dup_addr, 1), dups_ptrn);\n          return Pointer(dup_addr, 2);\n        }\n      }\n    };\n    switch (term[0]) {\n      case \"Dup\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level);\n        level_of[expr_ptr] = level;\n        var_ptrs.push(expr_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Put\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level + 1);\n        return expr_ptr;\n      case \"Lam\":\n        var lam_addr = net.alloc_node(NOD, 0);\n        net.link_ports(Pointer(lam_addr, 1), Pointer(lam_addr, 1));\n        level_of[Pointer(lam_addr, 1)] = level;\n        var_ptrs.push(Pointer(lam_addr, 1));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        net.link_ports(Pointer(lam_addr, 2), body_ptr);\n        return Pointer(lam_addr, 0);\n      case \"App\":\n        var app_addr = net.alloc_node(NOD, 0);\n        var func_ptr = build_net(term[1].func, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 0), func_ptr);\n        var argm_ptr = build_net(term[1].argm, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 1), argm_ptr)\n        return Pointer(app_addr, 2);\n      case \"Num\":\n        return Numeric(term[1].numb >>> 0);\n      case \"Op1\":\n        var op1_addr = net.alloc_node(OP1, op_kind[term[1].func]);\n        net.link_ports(Numeric(term[1].num1[1].numb), Pointer(op1_addr, 1));\n        var num0_ptr = build_net(term[1].num0, net, var_ptrs, level);\n        net.link_ports(num0_ptr, Pointer(op1_addr, 0));\n        return Pointer(op1_addr, 2);\n      case \"Op2\":\n        var op2_addr = net.alloc_node(OP2, op_kind[term[1].func]);\n        var num0_ptr = build_net(term[1].num0, net, var_ptrs, level);\n        net.link_ports(Pointer(op2_addr, 1), num0_ptr);\n        var num1_ptr = build_net(term[1].num1, net, var_ptrs, level);\n        net.link_ports(Pointer(op2_addr, 0), num1_ptr);\n        return Pointer(op2_addr, 2);\n      case \"Par\":\n        var par_addr = net.alloc_node(NOD, 0xFFFF);\n        var val0_ptr = build_net(term[1].val0, net, var_ptrs, level);\n        net.link_ports(Pointer(par_addr, 1), val0_ptr);\n        var val1_ptr = build_net(term[1].val1, net, var_ptrs, level);\n        net.link_ports(Pointer(par_addr, 2), val1_ptr);\n        return Pointer(par_addr, 0);\n      case \"Fst\":\n        var fst_addr = net.alloc_node(NOD, 0xFFFF);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(fst_addr, 0), pair_ptr);\n        net.link_ports(Pointer(fst_addr, 2), Pointer(fst_addr, 2));\n        return Pointer(fst_addr, 1);\n      case \"Snd\":\n        var snd_addr = net.alloc_node(NOD, 0xFFFF);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(snd_addr, 0), pair_ptr);\n        net.link_ports(Pointer(snd_addr, 1), Pointer(snd_addr, 1));\n        return Pointer(snd_addr, 2);\n      case \"Prj\":\n        var prj_addr = net.alloc_node(NOD, 0xFFFF);\n        level_of[Pointer(prj_addr, 1)] = level;\n        level_of[Pointer(prj_addr, 2)] = level;\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        var_ptrs.push(Pointer(prj_addr, 1));\n        var_ptrs.push(Pointer(prj_addr, 2));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        var_ptrs.pop();\n        net.link_ports(Pointer(prj_addr, 0), pair_ptr);\n        return body_ptr;\n      case \"Ite\":\n        var ite_addr = net.alloc_node(ITE, 0xFFFF);\n        var cond_ptr = build_net(term[1].cond, net, var_ptrs, level);\n        net.link_ports(Pointer(ite_addr, 0), cond_ptr);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(ite_addr, 1), pair_ptr);\n        return Pointer(ite_addr, 2);\n      case \"Cpy\":\n        var numb_ptr = build_net(term[1].numb, net, var_ptrs, level);\n        level_of[numb_ptr] = 0xFFFE;\n        var_ptrs.push(numb_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Var\":\n        return get_var(var_ptrs[var_ptrs.length - term[1].index - 1]);\n      case \"Ref\":\n        return build_net(defs[term[1].name], net, var_ptrs, level);\n      default:\n        return build_net(Lam(\"\", null, Var(0)), net, var_ptrs, level);\n    }\n  };\n  var level_of = {};\n  var net = new Net();\n  var root_addr = net.alloc_node(NOD, 0);\n  var term_ptr = build_net(term, net, [], 0);\n  net.link_ports(Pointer(root_addr, 0), Pointer(root_addr, 2));\n  net.link_ports(Pointer(root_addr, 1), term_ptr);\n  // Removes invalid redexes. They can be created by the\n  // compiler when duplicating variables more than once.\n  net.redex = net.redex.filter((a_addr) => {\n    var b_ptrn = net.enter_port(Pointer(a_addr, 0));\n    if (type_of(b_ptrn) !== NUM) {\n      var b_addr = addr_of(b_ptrn);\n      var a_p0 = Pointer(a_addr, 0);\n      var b_p0 = Pointer(b_addr, 0);\n      var a_ok = net.enter_port(a_p0) === b_p0;\n      var b_ok = net.enter_port(b_p0) === a_p0;\n      return a_ok && b_ok;\n    } else {\n      return true;\n    }\n  });\n  return net;\n};\n\nconst decompile = (net) => {\n  const build_term = (net, ptrn, var_ptrs, dup_exit) => {\n    if (type_of(ptrn) === NUM) {\n      return Num(numb_of(ptrn));\n    } else {\n      var addr = addr_of(ptrn);\n      var type = net.type_of(addr);\n      var kind = net.kind_of(addr);\n      if (type === NOD) {\n        if (kind === 0) {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var_ptrs.push(Pointer(addr, 1));\n              var body = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n              var_ptrs.pop();\n              return Lam(gen_name(var_ptrs.length), body);\n            case 1:\n              for (var index = 0; index < var_ptrs.length; ++index) {\n                if (var_ptrs[var_ptrs.length - index - 1] === ptrn) {\n                  return Var(index);\n                }\n              }\n            case 2:\n              var argm = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n              var func = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return App(func, argm);\n          }\n        } else if (kind === 0xFFFF) {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var val0 = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n              var val1 = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n              return Par(val0, val1);\n            case 1:\n              var pair = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return Fst(pair);\n            case 2:\n              var pair = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return Snd(pair);\n          }\n        } else {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var exit = dup_exit.pop();\n              var term = build_term(net, net.enter_port(Pointer(addr, exit)), var_ptrs, dup_exit);\n              dup_exit.push(exit);\n              return term;\n            default:\n              dup_exit.push(slot_of(ptrn));\n              var term = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              dup_exit.pop();\n              return term;\n          }\n        }\n      } else if (type === OP1) {\n        var num0 = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        var num1 = Num(numb_of(net.enter_port(Pointer(addr, 1))));\n        return Op1(op_kind[kind], num0, num1);\n      } else if (type === OP2) {\n        var num0 = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n        var num1 = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        return Op2(op_kind[kind], num0, num1);\n      } else if (type === ITE) {\n        var cond = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        var pair = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n        return Ite(cond, pair);\n      }\n    }\n  };\n  return build_term(net, net.enter_port(Pointer(0, 1)), [], []);\n};\n\nconst norm_with_stats = (term, defs = {}, lazy = true) => {\n  var net = compile(term, defs);\n  var stats = lazy ? net.reduce_lazy() : net.reduce();\n  var norm = decompile(net);\n  return {norm, stats};\n};\n\nconst norm = (term, defs, lazy) => {\n  return norm_with_stats(term, defs, lazy).norm;\n};\n\nmodule.exports = {compile, decompile, norm_with_stats, norm};\n\n\n//# sourceURL=webpack:///./node_modules/formality-core/fm-to-net.js?");

/***/ }),

/***/ "./node_modules/formality-net/fm-net.js":
/*!**********************************************!*\
  !*** ./node_modules/formality-net/fm-net.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ~~ Formality Interaction Net System ~~\n\nconst Pointer = (addr, port) => (addr << 2) + (port & 3);\nconst addr_of = (ptr) => ptr >>> 2;\nconst slot_of = (ptr) => ptr & 3;\nconst Numeric = (numb) => numb + 0x100000000;\nconst numb_of = (numb) => numb - 0x100000000;\nconst type_of = (ptrn) => ptrn >= 0x100000000 ? NUM : PTR;\n\n// PtrNum types\nconst PTR = 0;\nconst NUM = 1;\n\n// Node types\nconst NOD = 0;\nconst OP1 = 1;\nconst OP2 = 2;\nconst ITE = 3;\n\nclass Net {\n  // A net stores nodes (this.nodes), reclaimable memory addrs (this.freed) and active pairs (this.redex)\n  constructor() {\n    this.nodes = []; // nodes\n    this.freed = []; // integers\n    this.redex = []; // array of (integer, integer) tuples representing addrs\n    this.find_redex = true;\n  }\n\n  // Allocates a new node, return its addr\n  alloc_node(type, kind) {\n\n    // If there is reclaimable memory, use it\n    if (this.freed.length > 0) {\n      var addr = this.freed.pop();\n\n    // Otherwise, extend the array of nodes\n    } else {\n      var addr = this.nodes.length / 4;\n    }\n\n    // Fill the memory with an empty node without pointers\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = (kind << 6) + ((type & 0x7) << 3);\n    return addr;\n  }\n\n  // Deallocates a node, allowing its space to be reclaimed\n  free_node(addr) {\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = 0;\n    this.freed.push(addr);\n  }\n\n  is_free(addr) {\n    return this.nodes[addr * 4 + 0] === addr * 4 + 0\n        && this.nodes[addr * 4 + 1] === addr * 4 + 1\n        && this.nodes[addr * 4 + 2] === addr * 4 + 2\n        && this.nodes[addr * 4 + 3] === 0;\n  }\n\n  // Returns if given slot holds a number\n  is_numeric(addr, slot) {\n    return (this.nodes[addr * 4 + 3] >>> slot) & 1; \n  }\n\n  set_port(addr, slot, ptrn) {\n    if (type_of(ptrn) === NUM) {\n      this.nodes[addr * 4 + slot] = numb_of(ptrn);\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] | (1 << slot);\n    } else {\n      this.nodes[addr * 4 + slot] = ptrn;\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] & ~(1 << slot);\n    }\n  }\n\n  get_port(addr, slot) {\n    return this.nodes[addr * 4 + slot] + (this.is_numeric(addr, slot) ? 0x100000000 : 0);\n  }\n\n  type_of(addr) {\n    return (this.nodes[addr * 4 + 3] >>> 3) & 0x7;\n  }\n\n  set_type(addr, type) {\n    this.nodes[addr * 4 + 3] = (this.nodes[addr * 4 + 3] & ~0b111000) | (type << 3);\n  }\n\n  kind_of(addr) {\n    return this.nodes[addr * 4 + 3] >>> 6;\n  }\n\n  // Given a pointer to a port, returns a pointer to the opposing port\n  enter_port(ptrn) {\n    if (type_of(ptrn) === NUM) { \n      throw \"Can't enter a numeric pointer.\";\n    } else {\n      return this.get_port(addr_of(ptrn), slot_of(ptrn));\n    }\n  }\n\n  // Connects two ports\n  link_ports(a_ptrn, b_ptrn) {\n    var a_numb = type_of(a_ptrn) === NUM;\n    var b_numb = type_of(b_ptrn) === NUM;\n\n    // Point ports to each-other\n    if (!a_numb) this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), b_ptrn);\n    if (!b_numb) this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), a_ptrn);\n\n    // If both are main ports, add this to the list of active pairs\n    if (this.find_redex && !(a_numb && b_numb) && (a_numb || slot_of(a_ptrn) === 0) && (b_numb || slot_of(b_ptrn) === 0)) {\n      this.redex.push(a_numb ? addr_of(b_ptrn) : addr_of(a_ptrn));\n    }\n  }\n\n  // Disconnects a port, causing both sides to point to themselves\n  unlink_port(a_ptrn) {\n    if (type_of(a_ptrn) === PTR) {\n      var b_ptrn = this.enter_port(a_ptrn);\n      if (type_of(b_ptrn) === PTR && this.enter_port(b_ptrn) === a_ptrn) {\n        this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), a_ptrn);\n        this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), b_ptrn);\n      }\n    }\n  }\n\n  // Rewrites an active pair\n  rewrite(a_addr) {\n    var a_ptrn = Pointer(a_addr, 0);\n    var b_ptrn = this.get_port(a_addr, 0);\n    if (type_of(b_ptrn) === NUM) {\n      var a_type = this.type_of(a_addr);\n      var a_kind = this.kind_of(a_addr);\n\n      // UnaryOperation\n      if (a_type === OP1) {\n        var dst = this.enter_port(Pointer(a_addr, 2));\n        var fst = numb_of(b_ptrn);\n        var snd = numb_of(this.enter_port(Pointer(a_addr, 1)));\n        switch (a_kind) {\n          case  0: var res = Numeric((fst + snd) >>> 0); break;\n          case  1: var res = Numeric((fst - snd) >>> 0); break;\n          case  2: var res = Numeric((fst * snd) >>> 0); break;\n          case  3: var res = Numeric((fst / snd) >>> 0); break;\n          case  4: var res = Numeric((fst % snd) >>> 0); break;\n          case  5: var res = Numeric((fst ** snd) >>> 0); break;\n          case  6: var res = Numeric((fst ** (snd / (2 ** 32)) >>> 0)); break;\n          case  7: var res = Numeric((fst & snd) >>> 0); break;\n          case  8: var res = Numeric((fst | snd) >>> 0); break;\n          case  9: var res = Numeric((fst ^ snd) >>> 0); break;\n          case 10: var res = Numeric((~snd) >>> 0); break;\n          case 11: var res = Numeric((fst >>> snd) >>> 0); break;\n          case 12: var res = Numeric((fst << snd) >>> 0); break;\n          case 13: var res = Numeric((fst > snd ? 1 : 0) >>> 0); break;\n          case 14: var res = Numeric((fst < snd ? 1 : 0) >>> 0); break;\n          case 15: var res = Numeric((fst == snd ? 1 : 0) >>> 0); break;\n          default: throw \"[ERROR]\\nInvalid interaction.\";\n        }\n        this.link_ports(dst, res);\n        this.unlink_port(Pointer(a_addr, 0));\n        this.unlink_port(Pointer(a_addr, 2));\n        this.free_node(a_addr);\n      \n      // BinaryOperation\n      } else if (a_type === OP2) {\n        this.set_type(a_addr, OP1);\n        this.link_ports(Pointer(a_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.unlink_port(Pointer(a_addr, 1));\n        this.link_ports(Pointer(a_addr, 1), b_ptrn);\n    \n      // NumberDuplication\n      } else if (a_type === NOD) {\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 2)));\n        this.free_node(a_addr);\n\n      // IfThenElse\n      } else if (a_type === ITE) {\n        var pair_ptr = this.enter_port(Pointer(a_addr, 1));\n        var dest_ptr = this.enter_port(Pointer(a_addr, 2));\n        var cond_val = numb_of(b_ptrn) === 0;\n        this.set_type(a_addr, NOD);\n        this.link_ports(Pointer(a_addr, 0), pair_ptr);\n        this.link_ports(Pointer(a_addr, cond_val ? 1 : 2), Pointer(a_addr, cond_val ? 1 : 2));\n        this.link_ports(Pointer(a_addr, cond_val ? 2 : 1), dest_ptr);\n\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n\n    } else {\n      var b_addr = addr_of(b_ptrn);\n      var a_type = this.type_of(a_addr);\n      var b_type = this.type_of(b_addr);\n      var a_kind = this.kind_of(a_addr);\n      var b_kind = this.kind_of(b_addr);\n\n      // NodeAnnihilation, UnaryAnnihilation, BinaryAnnihilation\n      if ( a_type === NOD && b_type === NOD && a_kind === b_kind\n        || a_type === OP1 && b_type === OP1\n        || a_type === OP2 && b_type === OP2\n        || a_type === ITE && b_type === ITE) {\n        var a_aux1_dest = this.enter_port(Pointer(a_addr, 1));\n        var b_aux1_dest = this.enter_port(Pointer(b_addr, 1));\n        this.link_ports(a_aux1_dest, b_aux1_dest);\n        var a_aux2_dest = this.enter_port(Pointer(a_addr, 2));\n        var b_aux2_dest = this.enter_port(Pointer(b_addr, 2));\n        this.link_ports(a_aux2_dest, b_aux2_dest);\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // NodeDuplication, BinaryDuplication\n      } else if\n        (  a_type === NOD && b_type === NOD && a_kind !== b_kind\n        || a_type === NOD && b_type === OP2\n        || a_type === NOD && b_type === ITE) {\n        var p_addr = this.alloc_node(b_type, b_kind);\n        var q_addr = this.alloc_node(b_type, b_kind);\n        var r_addr = this.alloc_node(a_type, a_kind);\n        var s_addr = this.alloc_node(a_type, a_kind);\n        this.link_ports(Pointer(r_addr, 1), Pointer(p_addr, 1));\n        this.link_ports(Pointer(s_addr, 1), Pointer(p_addr, 2));\n        this.link_ports(Pointer(r_addr, 2), Pointer(q_addr, 1));\n        this.link_ports(Pointer(s_addr, 2), Pointer(q_addr, 2));\n        this.link_ports(Pointer(p_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(Pointer(q_addr, 0), this.enter_port(Pointer(a_addr, 2)));\n        this.link_ports(Pointer(r_addr, 0), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(s_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // UnaryDuplication\n      } else if\n        (  a_type === NOD && b_type === OP1\n        || a_type === ITE && b_type === OP1) {\n        var c_addr = this.alloc_node(OP1, b_kind);\n        this.link_ports(Pointer(c_addr, 1), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(a_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        this.link_ports(this.enter_port(Pointer(a_addr, 1)), Pointer(b_addr, 0));\n        this.link_ports(this.enter_port(Pointer(a_addr, 2)), Pointer(c_addr, 0));\n        this.link_ports(Pointer(a_addr, 1), Pointer(b_addr, 2));\n        this.link_ports(Pointer(a_addr, 2), Pointer(c_addr, 2));\n      \n      // Permutations\n      } else if (a_type === OP1 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === OP2 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === ITE && b_type === NOD) {\n        return this.rewrite(b_addr);\n\n      // InvalidInteraction\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This could be performed in parallel and doesn't need GC.\n  reduce_strict(stats) {\n    var rewrites = 0;\n    var loops = 0;\n    var max_len = 0;\n    while (this.redex.length > 0) {\n      for (var i = 0, l = this.redex.length; i < l; ++i) {\n        this.rewrite(this.redex.pop());\n        stats.max_len = Math.max(stats.max_len, this.nodes.length / 4);\n        ++stats.rewrites;\n      }\n      ++stats.loops;\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This avoids unecessary computations, but is sequential and would need GC.\n  reduce_lazy(stats) {\n    this.find_redex = false;\n    var warp = [];\n    var back = [];\n    var prev = Pointer(0, 1);\n    var next = this.enter_port(prev);\n    var rwts = 0;\n    while (true) {\n      ++stats.loops;\n      if (type_of(next) === PTR && (addr_of(next) === 0 || this.is_free(addr_of(next)))) {\n        if (warp.length === 0) {\n          break;\n        } else {\n          prev = warp.pop();\n          next = this.enter_port(prev);\n        }\n      } else {\n        if (slot_of(prev) === 0 && (type_of(next) === NUM || slot_of(next) === 0)) {\n          this.rewrite(addr_of(prev));\n          stats.rewrites += 1;\n          stats.max_len = Math.max(stats.max_len, this.nodes.length / 4);\n          do { prev = back.pop(); } while (type_of(prev) !== PTR);\n          next = this.enter_port(prev);\n          ++rwts;\n        } else if (type_of(next) === NUM) {\n          [prev,next] = [next,prev];\n        } else if (slot_of(next) === 0) {\n          if (this.type_of(addr_of(next)) !== OP1) {\n            warp.push(Pointer(addr_of(next), 1));\n          }\n          prev = Pointer(addr_of(next), 2);\n          next = this.enter_port(prev);\n        } else {\n          back.push(prev);\n          prev = Pointer(addr_of(next), 0);\n          next = this.enter_port(prev);\n        }\n      }\n    }\n    this.find_redex = true;\n  }\n\n  // Returns a string that is preserved on reduction, good for debugging\n  denote(ptrn = this.enter_port(Pointer(0, 1)), exit = []) {\n    function path_to_string(path) {\n      var str = \"<\";\n      while (path) {\n        str += path.head === 1 ? \"a\" : \"b\";\n        path = path.tail; \n      }\n      str += \">\";\n      return str;\n    }\n    while (true) {\n      if (type_of(ptrn) === PTR) {\n        var ai = addr_of(ptrn);\n        var as = slot_of(ptrn)\n        var ak = this.kind_of(ai);\n        switch (this.type_of(ai)) {\n          case NOD:\n            if (slot_of(ptrn) === 0) {\n              if (exit[ak]) {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = new_exit[ak].tail;\n                ptrn = this.enter_port(Pointer(ai, Number(exit[ak].head)));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              } else {\n                var lft = this.denote(this.enter_port(Pointer(ai, 1)), exit);\n                var rgt = this.denote(this.enter_port(Pointer(ai, 2)), exit);\n                return \"(\" + ak + \" \" + lft + \" \" + rgt + \")\";\n              }\n            } else {\n              if (ai === 0) {\n                while (exit[exit.length - 1] === null) exit.pop();\n                return exit.map(path_to_string).join(\":\");\n              } else {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = {head: as, tail: new_exit[ak] || null};\n                ptrn = this.enter_port(Pointer(ai, 0));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              }\n            }\n            break;\n          default:\n            return \"<TODO>\";\n        }\n      } else {\n        return \"#\" + numb_of(ptrn);\n      }\n    }\n  }\n\n  to_string() {\n    const pointer = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return \"#\" + numb_of(ptrn);\n      } else {\n        return addr_of(ptrn) + \"abc\"[slot_of(ptrn)];\n      }\n    };\n    var text = '';\n    for (var i = 0; i < this.nodes.length / 4; i++) {\n      if (this.is_free(i)) {\n        text += i + \": ~\\n\";\n      } else {\n        var type = this.type_of(i);\n        var kind = this.kind_of(i);\n        text += i + ': ';\n        text += \"[\" + type + \":\" + kind + \"| \";\n        text += pointer(this.get_port(i, 0)) + \" \";\n        text += pointer(this.get_port(i, 1)) + \" \";\n        text += pointer(this.get_port(i, 2)) + \"]\";\n        text += \"...\" + this.is_numeric(i,0) + \" \" + this.is_numeric(i,1) + \" \" + this.is_numeric(i,2);\n        text += \"\\n\";\n      }\n    }\n    return text;\n  }\n}\n\nmodule.exports = {Pointer, addr_of, slot_of, Numeric, numb_of, type_of, Net, NUM, PTR, NOD, OP1, OP2, ITE};\n\n\n//# sourceURL=webpack:///./node_modules/formality-net/fm-net.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./src/canvas.js":
/*!***********************!*\
  !*** ./src/canvas.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Creates a new canvas\nfunction Canvas(width, height) {\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = width * 2;\n  canvas.height = height * 2;\n  canvas.style.width = width + \"px\";\n  canvas.style.height = height + \"px\";\n  canvas.style.margin = \"0px\";\n  canvas.style.padding = \"0px\";\n\n  var context = canvas.getContext(\"2d\");\n  context.imageSmoothingEnabled = false;\n  context.font = \"10px Arial\";\n  context.textBaseline = \"middle\"; \n  context.textAlign = \"center\";\n\n  canvas.context = context;\n  canvas.context.scale(2,2);\n  return canvas;\n};\n\nmodule.exports = Canvas;\n\n\n//# sourceURL=webpack:///./src/canvas.js?");

/***/ }),

/***/ "./src/image.js":
/*!**********************!*\
  !*** ./src/image.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Image\nconst Image = (src) => {\n  var image = document.createElement(\"img\");\n  image.src = \"img/\" + src;\n  //image.onload = () => {\n    //if (flip) offset[0] = - offset[0];\n    //offset[0] -= image.width * 0.5;\n    //offset[1] -= image.height * 0.5;\n  //};\n  //image.offset = offset;\n  //document.body.appendChild(image);\n  return image;\n};\n\n// Images\nconst images = {\n  effects: {\n    shadow_flux: [\n      Image(\"effects/shadow_flux/shadow_flux-0.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-1.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-2.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-3.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-4.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-5.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-6.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-7.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-8.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-9.png\"),\n      Image(\"effects/shadow_flux/shadow_flux-10.png\"),\n    ]\n  },\n  item: {\n    hourglass: Image(\"item/hourglass.png\")\n  },\n  tophoro: {\n    left: [\n      Image(\"heroes/tophoro.png\"),\n    ]\n  },\n  gonk: {\n    left: [\n      Image(\"heroes/gonk.png\"),\n    ]\n  },\n  stanci: {\n    left: [\n      Image(\"heroes/stanci.png\"),\n    ]\n  },\n  erkos: {\n    left: [\n      Image(\"heroes/erkos.png\"),\n    ]\n  },\n  croni: {\n    idle: {\n      left: [\n        Image(\"croni/Idle/Croni_Idle_00.png\"),\n        Image(\"croni/Idle/Croni_Idle_01.png\"),\n        Image(\"croni/Idle/Croni_Idle_02.png\"),\n        Image(\"croni/Idle/Croni_Idle_03.png\"),\n        Image(\"croni/Idle/Croni_Idle_04.png\"),\n        Image(\"croni/Idle/Croni_Idle_05.png\"),\n        Image(\"croni/Idle/Croni_Idle_06.png\"),\n        Image(\"croni/Idle/Croni_Idle_07.png\"),\n        Image(\"croni/Idle/Croni_Idle_08.png\"),\n        Image(\"croni/Idle/Croni_Idle_09.png\"),\n        Image(\"croni/Idle/Croni_Idle_10.png\"),\n        Image(\"croni/Idle/Croni_Idle_11.png\"),\n        Image(\"croni/Idle/Croni_Idle_12.png\"),\n        Image(\"croni/Idle/Croni_Idle_13.png\"),\n        Image(\"croni/Idle/Croni_Idle_14.png\"),\n        Image(\"croni/Idle/Croni_Idle_15.png\"),\n        Image(\"croni/Idle/Croni_Idle_16.png\"),\n        Image(\"croni/Idle/Croni_Idle_17.png\"),\n        Image(\"croni/Idle/Croni_Idle_18.png\"),\n        Image(\"croni/Idle/Croni_Idle_19.png\"),\n        Image(\"croni/Idle/Croni_Idle_20.png\"),\n        Image(\"croni/Idle/Croni_Idle_21.png\"),\n        Image(\"croni/Idle/Croni_Idle_22.png\"),\n        Image(\"croni/Idle/Croni_Idle_23.png\"),\n      ]\n    },\n    move: {\n      left: [\n        Image(\"croni/Move_LR/Croni_Move_LR_0.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_1.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_2.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_3.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_4.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_5.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_6.png\"),\n        Image(\"croni/Move_LR/Croni_Move_LR_7.png\"),\n      ]\n    },\n    shadow_flux: {\n      left: [\n        Image(\"croni/Attack_LR/Croni_Attack_LR_00.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_01.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_02.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_03.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_04.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_05.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_06.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_07.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_08.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_09.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_10.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_11.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_12.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_13.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_14.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_15.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_16.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_17.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_18.png\"),\n        Image(\"croni/Attack_LR/Croni_Attack_LR_19.png\"),\n      ]\n    }\n  },\n  snarch: {\n    left: [\n      Image(\"heroes/snarch.png\"),\n    ]\n  },\n  sirpix: {\n    left: [\n      Image(\"heroes/sirpix.png\"),\n    ]\n  },\n  kenlua: {\n    left: [\n      Image(\"heroes/kenlua.png\"),\n    ]\n  },\n  flina: {\n    left: [\n      Image(\"heroes/flina.png\"),\n    ]\n  },\n  zagatur: {\n    left: [\n      Image(\"heroes/zagatur.png\"),\n    ]\n  },\n  agdris: {\n    left: [\n      Image(\"heroes/agdris.png\"),\n    ]\n  },\n  mewem: {\n    left: [\n      Image(\"heroes/mewem.png\"),\n    ]\n  },\n  //thief: {\n    //right: [\n      //Image(\"thief/frame_00r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_01r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_02r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_03r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_04r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_05r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_06r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_07r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_08r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_09r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_10r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_11r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_12r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_13r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_14r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_15r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_16r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_17r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_18r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_19r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_20r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_21r.gif\", [-28,-16], 1),\n      //Image(\"thief/frame_22r.gif\", [-28,-16], 1),\n    //],\n    //left: [\n      //Image(\"thief/frame_00.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_01.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_02.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_03.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_04.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_05.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_06.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_07.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_08.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_09.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_10.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_11.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_12.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_13.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_14.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_15.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_16.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_17.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_18.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_19.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_20.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_21.gif\", [-28,-16], 0),\n      //Image(\"thief/frame_22.gif\", [-28,-16], 0),\n    //],\n  //}\n};\n\nmodule.exports = {Image, images};\n\n\n//# sourceURL=webpack:///./src/image.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ::::::::::\n// :: Game ::\n// ::::::::::\n\nconst images     = __webpack_require__(/*! ./image.js */ \"./src/image.js\").images;\nconst Keyboard   = __webpack_require__(/*! ./keyboard.js */ \"./src/keyboard.js\");\nconst Canvas     = __webpack_require__(/*! ./canvas.js */ \"./src/canvas.js\");\nconst kaelin     = __webpack_require__(/*! ./kaelin.js */ \"./src/kaelin.js\");\nconst parse_cast = __webpack_require__(/*! ./parse_cast.js */ \"./src/parse_cast.js\");\nconst dist       = ([ax,ay],[bx,by]) => Math.abs(ax-bx) + Math.abs(ay-by);\nconst CAST_TIME  = 8;\nconst TICK_TIME  = 2.0;\nconst now        = () => Date.now() / 1000;\n\n// Renders the board to a canvas\nconst tile_size    = 32;\nconst pos_to_coord = ([i,j]) => [(i + 0.5) * tile_size, (j + 0.5) * tile_size];\nconst coord_to_pos = ([x,y]) => [Math.max(0, Math.min(Math.floor(x / tile_size - 0.5), 15)), Math.max(0, Math.min(Math.floor(y / tile_size - 0.5), 15))];\n\n// Renders the game\nconst render_game = (game, canvas) => {\n\n  var tick = game.ticks[Math.floor(game.index)];\n  var board = kaelin.board_to_json(tick.board);\n\n  var prev_tick = game.ticks[Math.floor(Math.max(game.index - 1, 0))];\n  var prev_board = kaelin.board_to_json(prev_tick.board);\n\n  // Finds hero positions\n  var hero_pos = {};\n  var prev_hero_pos = {};\n  for (var j = 0; j < 16; ++j) {\n    for (var i = 0; i < 16; ++i) {\n      var unit = board[j * 16 + i];\n      if (isHero(unit)) {\n        hero_pos[unit[1].hero] = [i,j];\n      }\n      var prev_unit = prev_board[j * 16 + i];\n      if (isHero(prev_unit)) {\n        prev_hero_pos[prev_unit[1].hero] = [i,j];\n      }\n    }\n  }\n\n  // Clears screen\n  canvas.context.clearRect(0, 0, canvas.width, canvas.height);\n  if (game.index < game.ticks.length - 1) {\n    canvas.context.fillStyle = \"rgb(200,200,200)\";\n  } else {\n    canvas.context.fillStyle = \"rgb(230,230,230)\";\n  }\n  canvas.context.rect(0, 0, canvas.width, canvas.height);\n  canvas.context.fill();\n\n  // Renders turn info\n  if (game.casting && now() - game.casting < CAST_TIME) {\n    var top_text = \"Casting in \" + (CAST_TIME - (now() - game.casting)).toFixed(2) + \" seconds...\";\n  } else {\n    var top_text = tick.text;\n  }\n  var bottom_text = \"Tick \" + Math.floor(game.index) + \"/\" + (game.ticks.length - 1) + \", Turn \" + tick.turn + \".\";\n  canvas.context.font = \"12px monospace\";\n  canvas.context.textAlign = \"center\"; \n  canvas.context.textBaseline = \"middle\"; \n  canvas.context.fillStyle = \"black\";\n  canvas.context.fillText(bottom_text, tile_size * 8, tile_size * 16.75);\n  canvas.context.fillText(top_text, tile_size * 8, tile_size * 0.25);\n\n  // Draws tiles\n  for (var j = 0; j < 16; ++j) {\n    for (var i = 0; i < 16; ++i) {\n      var [x,y] = pos_to_coord([i,j]);\n      canvas.context.beginPath();\n      canvas.context.rect(x, y, tile_size, tile_size);\n      var unit = board[j * 16 + i];\n\n      // Highlights hero walk range\n      if (  game.my_hero\n        && hero_pos[game.my_hero]\n        && dist([i,j], hero_pos[game.my_hero]) <= 3\n        && game.casting && now() - game.casting < CAST_TIME) {\n        canvas.context.fillStyle = \"rgba(64,128,64,0.3)\";\n        canvas.context.fill();\n      }\n\n      // Highlights target & caster positions\n      if (tick.cast) {\n        if (dist(tick.cast[1], [i,j]) <= kaelin.get_skill_area(tick.cast[0])) {\n          if (tick.cast[0] % 4 === 0) { // Moving to position\n            canvas.context.fillStyle = \"rgba(32,128,128,0.5)\";\n          } else { // Skill area       \n            canvas.context.fillStyle = \"rgba(128,32,32,0.5)\";\n          }\n          canvas.context.fill();\n        }\n        // Caster position\n        if (isHero(unit) && unit[1].hero === Math.floor(tick.cast[0] / 4)) {\n          canvas.context.fillStyle = \"rgba(64,64,64,0.3)\";\n          canvas.context.fill();\n        }\n      }\n      canvas.context.strokeStyle = \"rgba(128,128,128,0.15)\";\n      canvas.context.stroke();\n      canvas.context.closePath();\n      // Coordinate\n      canvas.context.font = \"10px courier new\";\n      canvas.context.textAlign = \"center\"; \n      canvas.context.textBaseline = \"middle\"; \n      canvas.context.fillStyle = \"rgb(64,64,64)\";\n      canvas.context.fillText(String(i.toString(16)) + String(j.toString(16)), x + tile_size * 0.5, y + tile_size * 0.5);\n    }\n  }\n\n  // Draws units\n  for (var j = 0; j < 16; ++j) {\n    for (var i = 0; i < 16; ++i) {\n      var [x,y] = pos_to_coord([i,j]);\n      var unit  = board[j * 16 + i];\n      switch (unit[0]) {\n        case \"Void\":\n          break;\n        case \"Item\":\n          if (unit[1].type === 2) {\n            var image = images.item.hourglass;\n            canvas.context.drawImage(image, x + tile_size * 0.5 - image.width / 2, y + tile_size * 0.5 - image.height / 2);\n          } else {\n            canvas.context.fillStyle = \"rgb(64,64,64)\";\n            canvas.context.beginPath();\n            canvas.context.rect(x, y, tile_size, tile_size);\n            canvas.context.fill();\n            canvas.context.closePath();\n          }\n          break;\n        case \"Goal\":\n          canvas.context.fillStyle = \"rgb(128,64,64)\";\n          canvas.context.beginPath();\n          canvas.context.rect(x, y, tile_size, tile_size);\n          canvas.context.fill();\n          canvas.context.closePath();\n          break;\n        case \"Hero\":\n          canvas.context.font = \"bold 10px courier new\";\n          canvas.context.textAlign = \"center\"; \n          canvas.context.textBaseline = \"middle\"; \n          canvas.context.fillStyle = \"black\";\n          canvas.context.fillText(\n            unit[1].life\n            + (unit[1].defs ? \"+\" + unit[1].defs : \"\")\n            + (unit[1].lock > 0 ? \"L\" : \"\")\n            + (unit[1].mute > 0 ? \"M\" : \"\")\n            + (unit[1].spec > 0 ? \"*\" : \"\"),\n            x + 16,\n            y + 27);\n          var hero = getHeroCode(unit);\n          var name = getHeroName(hero);\n          if (name === \"Croni\") {\n            var delta = now() - (game.begin_anim || 0);\n            if (tick.cast && Math.floor(tick.cast[0] / 4) === hero && tick.cast[0] % 4 === 0) {\n              var [px,py] = pos_to_coord(prev_hero_pos[hero]);\n              var x = px + (x - px) * delta / TICK_TIME;\n              var y = py + (y - py) * delta / TICK_TIME;\n              var frames = images[name.toLowerCase()].move.left;\n            } else if (tick.cast && Math.floor(tick.cast[0] / 4) === hero && tick.cast[0] % 4 === 3) {\n              var frames = images[name.toLowerCase()].shadow_flux.left;\n              if (delta > 0.7 && delta < 1.8) {\n                var effect = images.effects.shadow_flux[Math.min(Math.floor((delta - 0.7) * 10), 10)];\n                var [tx,ty] = pos_to_coord(tick.cast[1]);\n                canvas.context.drawImage(effect, tx + tile_size * 0.5 - effect.width / 2, ty + tile_size * 0.5 - effect.height / 2);\n              }\n            } else {\n              var frames = images[name.toLowerCase()].idle.left;\n            }\n            var image = frames[Math.floor(delta * 10) % frames.length];\n          } else {\n            var image = images[name.toLowerCase()].left[0];\n          }\n          canvas.context.drawImage(image, x + tile_size * 0.5 - image.width / 2, y + tile_size * 0.5 - image.height / 2);\n          break;\n      }\n    }\n  }\n\n  // Mark the tile where casting a skill\n  if (game.my_hero !== null) {\n    for (var n = 0; n < 4; ++n) {\n      if (game.my_casts[n]) {\n        var [i,j] = game.my_casts[n];\n        var [x,y] = pos_to_coord([i,j]);\n        canvas.context.font = \"bold 24px monospace\";\n        canvas.context.textAlign = \"center\"; \n        canvas.context.textBaseline = \"middle\"; \n        canvas.context.fillStyle = \"black\";\n        canvas.context.fillText(\"XSDF\"[n], x + tile_size * 0.5, y + tile_size * 0.5);\n      }\n    }\n      \n  }\n};\n\nfunction isCastingTurn(game) {\n  return game.casting && now() - game.casting < CAST_TIME;\n}\n\nconst fm_string_to_string = str => {\n  var read_4_chars = n => {\n    var str = \"\";\n    str += String.fromCharCode((n >>>  0) & 0xFF);\n    str += String.fromCharCode((n >>>  8) & 0xFF);\n    str += String.fromCharCode((n >>> 16) & 0xFF);\n    str += String.fromCharCode((n >>> 24) & 0xFF);\n    return str;\n  };\n  return str[1](w => ws => read_4_chars(w) + ws)(\"\");\n};\n\nconst serialize_casts = (game) => {\n  if (game.my_hero !== null) {\n    var cast = \"@\" + kaelin.hero_name[game.my_hero].slice(0, 2).toLowerCase();\n    for (var n = 0; n < 4; ++n) {\n      var pos = game.my_casts[n];\n      cast += \" \" + (pos ? pos[0].toString(16) + pos[1].toString(16) : \".\");\n    }\n    return cast;\n  } else {\n    return null;\n  }\n};\n\nfunction isHero(unit) {\n  return unit[0] === \"Hero\";\n}\n\nfunction getHeroCode(unit) {\n  return unit[1].hero;\n}\n\nfunction getHeroName(code) {\n  return kaelin.hero_name[code];\n}\n\nwindow.onload = () => {\n\n  // Name\n  if (!localStorage.getItem(\"name\")) {\n    localStorage.setItem(\"name\", prompt(\"Your name:\"));\n  }\n  var name = localStorage.getItem(\"name\");\n\n  // State\n  var game;\n  function new_game() {\n    game = {\n      index: 0,\n      ticks: [{turn: 0, text: \"Game begins.\", cast: null, board: kaelin.new_board}],\n      casts: [],\n      mouse: [0,0],\n      manual: false,\n      turn: 0,\n      begin_anim: null,\n      my_hero: null,\n      my_casts: [null, null, null, null]\n    };\n    render_game(game, canvas);\n  };\n\n  const add_index = (add) => {\n    console.log(\"Add index\");\n    if (add > 0 && game.index < game.ticks.length - 1) {\n      game.index += 1;\n      game.begin_anim = now();\n      if (game.index === game.ticks.length - 1) {\n        game.manual = false;\n        post(\"Finish your casts. You have \" + CAST_TIME + \" seconds!\", \"log_green\");\n        game.casting = now();\n        castingTurn(game);\n      }\n    } else if (add < 0) { // Manually returning to previous state\n      game.index = Math.max(game.index + add, 0);\n      game.begin_anim = now();\n      game.manual = true;\n    }\n  };\n\n  const castingTurn = (game) => {\n    setTimeout(() => {\n      var serialized = serialize_casts(game);\n      game.my_casts = [null, null, null, null];\n      if (serialized) { \n        ws.send(name + \": \" + serialized);\n        post(\"Sending \" + game.casts.length + \" casts.\", \"log_green\");\n      } else {\n        post(\"No casts for now.\");\n      }\n      nextTurn();\n      render_game(game, canvas);\n    }, CAST_TIME * 1000);\n  }\n\n\n  // ------\n  // Canvas\n  // ------\n  var canvas = Canvas(tile_size * 16 + 32, tile_size * 16 + 32);\n  document.getElementById(\"board_box\").appendChild(canvas);\n\n  // TODO: mais de uma pessoa pode dar o /next? \n  const nextTurn = () => {\n      setTimeout(() => {\n        ws.send(name + \": /next\");\n      }, 1000);\n  }\n\n  function getUnitOnFocus() {\n    var tick = game.ticks[Math.floor(game.index)];\n    var unit = kaelin.unit_to_json(kaelin.get_at(game.mouse)(tick.board)[1]);\n    return unit\n  }\n  \n  // ---------\n  // Keyboard\n  // ---------\n  document.body.onkeydown = e => {\n\n    // Manually controls turns prev/next    \n    if (e.key === \"ArrowLeft\" || e.key === \"ArrowRight\") {\n      add_index(e.key === \"ArrowLeft\" ? -1 : e.key === \"ArrowRight\" ? 1 : 0);\n    }\n\n    // Selects cast positions\n    if (/[xfds]/.test(e.key) && game.my_hero !== null) {\n      var slot = ({f: 3, d: 2, s: 1, x: 0})[e.key];\n      var tick = game.ticks[Math.floor(game.index)];\n      var unit = kaelin.unit_to_json(kaelin.get_at(game.mouse)(tick.board)[1]);\n      if (game.my_casts[slot] && dist(game.my_casts[slot], game.mouse) === 0) {\n        game.my_casts[slot] = null;\n      } else {\n        game.my_casts[slot] = [game.mouse[0], game.mouse[1]];\n      }\n    }\n\n    // Sends pass-turn command\n    // if (e.key === \".\") {\n    //   if (game.index < game.ticks.length - 1) {\n    //     game.index = game.ticks.length - 1;\n    //   } else {\n    //     ws.send(name + \": \" + \"/next\");\n    //   }\n    // }\n\n    // Removes selected\n    if (e.key === \"Escape\") {\n      game.my_casts = [null, null, null, null];\n    }\n\n    render_game(game, canvas);\n  };\n\n  // Register mouse position\n  canvas.onmousemove = e => {\n    var [x,y] = [e.offsetX, e.offsetY];\n    var [i,j] = coord_to_pos([x,y]);\n    game.mouse = [i,j];\n  };\n\n  // TODO: adiconar herÃ³is Ã  sessÃ£o. \n\n  // Selects an unit\n  canvas.onclick = e => {\n    // Selects an unit before starting the game\n    if (game.index === 0){\n      // var tick = game.ticks[Math.floor(game.index)];\n      // var unit = kaelin.unit_to_json(kaelin.get_at(game.mouse)(tick.board)[1]);\n      var unit = getUnitOnFocus();\n      if (isHero(unit)) {\n        game.my_hero = getHeroCode(unit);\n        game.my_casts = [null, null, null, null];\n        post(\"Hero selected: \"+getHeroName(game.my_hero), \"log_green\");\n      }\n    }\n    render_game(game, canvas);\n  };\n\n  // Sends my casts\n  const send_casts = () => {\n    ws.send(name + \": \" + serialize_casts(game));\n    game.my_casts = [null, null, null, null];\n  };\n\n  // Posts something on chat\n  const post = (msg, className) => { \n    var msg_el = document.createElement(\"div\");\n    msg_el.className = \"message \" + className;\n    msg_el.innerText = msg;\n    // if (msg.slice(-5) !== \"RESET\") {\n    //   chat.appendChild(msg_el);\n    // }\n    chat.appendChild(msg_el);\n    chat_box.scrollTop = chat_box.scrollHeight;\n  };\n  // --------\n  // Messages\n  // --------\n  let msgs = [];\n  const on_message = (line) => {\n    var player = line.slice(0, line.indexOf(\":\"));\n    var msg = line.slice(line.indexOf(\":\") + 2);\n\n    console.log(\">> message: \"+msg);\n\n    post(player + \": \" + msg);\n\n    // If it is a cast, parses it\n    if (msg[0] === \"@\") {\n      var new_casts = [];\n      var lines = msg.split(\"@\").filter(line => line.length > 0);\n      for (var i = 0; i < lines.length; ++i) {\n        try {\n          new_casts = new_casts.concat(parse_cast(lines[i]).filter(cast => cast[1] !== null));\n        } catch (e) {\n          post(\"[ERROR] On cast \" + i + \": \" + e, \"red_log\");\n        }\n      }\n      game.casts = game.casts.concat(new_casts);\n      post(\"Added \" + new_casts.length + \" casts to turn \" + game.turn + \"! Total: \" + game.casts.length + \".\", \"green_log\");\n    }\n\n    if (msg === \"/next\") {\n      var casts = kaelin.sort_casts(game.casts);\n      for (var i = 0; i < casts.length; ++i) {\n        var show_args = args => typeof args === \"object\" ? args[0].toString(16) + args[1].toString(16) : String(args);\n        var hero = kaelin.hero_name[Math.floor(casts[i][0] / 4)];\n        var skill = kaelin.skill_name[casts[i][0]];\n        var args = \"(\" + show_args(casts[i][1]) + \")\";\n        var turn_message = hero + \" used \" + skill + args + \".\";\n        var tick = game.ticks[game.ticks.length - 1];\n        var new_board = kaelin.cast(casts[i])(tick.board);\n        game.ticks.push({\n          turn: game.turn,\n          text: turn_message,\n          cast: casts[i],\n          board: new_board\n        });\n      };\n      game.ticks.push({\n        turn: game.turn,\n        text: \"End turn.\",\n        cast: null,\n        board: kaelin.end_turn(game.ticks[game.ticks.length - 1].board)\n      });\n      post(\"Completed turn \" + game.turn + \" with \" + game.casts.length + \" casts!\", \"green_log\");\n      ++game.turn;\n      game.casts = [];\n      render_game(game, canvas);\n    }\n\n    // if (msg === \"$\") {\n    //   console.log(\"Initiating a new game\")\n    //   game.casts = [];\n    //   game.ticks.push([0, \"Game begins.\", [skill, args], kaelin.new_board]);\n    //   game.turn = 0;\n    //   post(\"Starting a new game!\", \"green_log\");\n    // }\n    \n    // TODO: not working\n    if (msg === \"/finish\") {\n      console.log(\"Finish game\");\n      new_game();\n      game.ticks.push([0, \"Game finished by user.\", [skill, args], kaelin.new_board]);\n      chat.innerHTML = \"\";\n    }\n\n    if (msg === \"/ready\") {\n      nextTurn();\n    }\n  }\n  // ----------\n  // Connection\n  // ----------\n  const ws = new WebSocket(\"ws://\" + location.host + \"/chat\");\n  ws.onopen = function open() {};\n  ws.onmessage = (data) => on_message(data.data);\n  // ----\n  // Chat\n  // ----\n  var chat = document.createElement(\"div\");\n  var chat_box = document.getElementById(\"chat_box\");\n  var input = document.getElementById(\"input\");\n  chat.style.width = \"100%\";\n  chat.style.height = \"100%\";\n  chat_box.appendChild(chat);\n  input.onkeypress = function(e) {\n    if (e.key === \"Enter\") {\n      ws.send(name + \": \" + input.value);\n      setTimeout(() => {\n        input.value = \"\";\n      }, 0);\n    }\n  };\n\n  // Tips\n  var tips_box = document.getElementById(\"tips_box\");\n  var tips = [\n    \"Hero    | Skill S           | Skill D             | Skill F\",\n    \"------- | ----------------- | ------------------- | -----------------\",\n    \"TOPHORO | Earth_Root*       | Earth_Wall*         | Earth_Rise       \",\n    \"GONK    | Empathy*          | Revenge*            | Ground_Slam      \",\n    \"STANCI  | Restore*          | Escort*             | Detain*          \",\n    \"ERKOS   | Flame_Ball        | Flame_Wave          | Flame_Nova       \",\n    \"CRONI   | Shadow_Bond*      | Shadow_Trap*        | Shadow_Flux      \",\n    \"SNARCH  | Ballista*         | Quick_Bolt_0*       | Quick_Bolt_1*    \",\n    \"SIRPIX  | Stealth_Move*     | Stealth_Strike*     | Lockpick         \",\n    \"KENLUA  | Haste*            | Dodge*              | Slash            \",\n    \"FLINA   | Javelin*          | Fly                 | Gust             \",\n    \"ZAGATUR | Wrap*             | Needle              | Summon           \",\n    \"AGDRIS  | Memento*          | Silence*            | Protect*         \",\n    \"MEWRU   | Teleport*         | Psychock            | Imprison         \",\n\n  ].join(\"\\n\");\n  tips_box.innerText = tips;\n\n  // Animation\n  setInterval(() => {\n    if (!game.manual && game.index < game.ticks.length - 1) {\n      add_index(1);\n      //game.index += 1;\n      render_game(game, canvas);\n    }\n  }, TICK_TIME * 1000);\n\n  // Rendering\n  setInterval(() => {\n    render_game(game, canvas);\n  }, 100);\n\n  new_game();\n};\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/kaelin.js":
/*!***********************!*\
  !*** ./src/kaelin.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const fm = __webpack_require__(/*! formality-core */ \"./node_modules/formality-core/exports.js\");\n\n//try {\n  var code = __webpack_require__(/*! ./../../formality/stdlib/_export_to_webpack_.js */ \"../formality/stdlib/_export_to_webpack_.js\");\n//} catch (e) {\n  //var code = require(\"./../../formality-core/examples/_export_to_node_.js\");\n//}\n\nconst {infs, defs} = fm.core.parse(code);\nconst compile      = name => fm.to_js.compile(defs[name], defs);\nconst Cons         = compile(\"Stack.push\");\nconst Nil          = compile(\"Stack.new\");\nconst\n  [new_board,\n  [cast,\n  [print_board,\n  [unit_to_scott,\n  [get_skill_priority,\n  [get_skill_area,\n  [get_at,\n  [end_turn,\n  [TOPHORO,\n  [GONK,\n  [STANCI,\n  [HERO_03,\n  [ERKOS,\n  [CRONI,\n  [SNARCH,\n  [HERO_07,\n  [SIRPIX,\n  [KENLUA,\n  [FLINA,\n  [HERO_11,\n  [ZAGATUR,\n  [AGDRIS,\n  [MEWEM,\n  [HERO_15,\n  ]]]]]]]]]]]]]]]]]]]]]]]]\n  = compile(\"kaelin\");\n\nconst sort_casts = casts => {\n  var map = {};\n  for (var i = 0; i < casts.length; ++i) {\n    map[get_skill_priority(casts[i][0])] = casts[i];\n  }\n  var new_casts = [];\n  for (var i = 0; i < 64; ++i) {\n    if (map[i]) {\n      new_casts.push(map[i]);\n    }\n  }\n  return new_casts;\n};\n\nconst skill_name = {\n  0: \"TOPHORO_WALK\",\n  1: \"EARTH_ROOT\",\n  2: \"EARTH_WALL\",\n  3: \"EARTH_RISE\",\n  4: \"GONK_WALK\",\n  5: \"EMPATHY\",\n  6: \"REVENGE\",\n  7: \"GROUND_SLAM\",\n  8: \"STANCI_WALK\",\n  9: \"RESTORE\",\n  10: \"ESCORT\",\n  11: \"DETAIN\",\n  16: \"ERKOS_WALK\",\n  17: \"FLAME_BALL\",\n  18: \"FLAME_WAVE\",\n  19: \"FLAME_NOVA\",\n  20: \"CRONI_WALK\",\n  21: \"SHADOW_BOND\",\n  22: \"SHADOW_TRAP\",\n  23: \"SHADOW_FLUX\",\n  24: \"SNARCH_WALK\",\n  25: \"BALLISTA\",\n  26: \"QUICK_BOLT_0\",\n  27: \"QUICK_BOLT_1\",\n  32: \"SIRPIX_WALK\",\n  33: \"STEALTH_MOVE\",\n  34: \"STEALTH_STRIKE\",\n  35: \"LOCKPICK\",\n  36: \"KENLUA_WALK\",\n  37: \"HASTE\",\n  38: \"DODGE\",\n  39: \"SLASH\",\n  40: \"FLINA_WALK\",\n  41: \"JAVELIN\",\n  42: \"FLY\",\n  43: \"GUST\",\n  48: \"ZAGATUR_WALK\",\n  49: \"NEEDLE\",\n  50: \"WRAP\",\n  51: \"SUMMON\",\n  52: \"AGDRIS_WALK\",\n  53: \"PROTECT\",\n  54: \"SILENCE\",\n  55: \"MEMENTO\",\n  56: \"MEWEN_WALK\",\n  57: \"TELEPORT\",\n  58: \"PSYCHOCK\",\n  59: \"IMPRISON\",\n};\n\nconst hero_name = {\n  0: \"Tophoro\",\n  1: \"Gonk\",\n  2: \"Stanci\",\n  3: \"?????\",\n  4: \"Erkos\",\n  5: \"Croni\",\n  6: \"Snarch\",\n  7: \"?????\",\n  8: \"Sirpix\",\n  9: \"Kenlua\",\n  10: \"Flina\",\n  11: \"?????\",\n  12: \"Zagatur\",\n  13: \"Agdris\",\n  14: \"Mewem\",\n  15: \"?????\",\n};\n\n// Converts board to JSON\nconst unit_to_json = unit => {\n  let case_void = [\"Void\"];\n  let case_item = type => [\"Item\", {type}];\n  let case_goal = side => [\"Goal\", {side}];\n  let case_hero = side => hero => life => defs => eff1 => lock => mute => spec => [\"Hero\", {side, hero, life, defs, eff1, lock, mute, spec}];\n  return unit_to_scott(unit)(case_void)(case_item)(case_goal)(case_hero);\n};\n\n// Converts board to JSON\nconst board_to_json = (val, i = 0) => {\n  if (i < 8) {\n    return board_to_json(val[0], i + 1).concat(board_to_json(val[1], i + 1));\n  } else {\n    return [unit_to_json(val)];\n  }\n};\n\nmodule.exports = {\n  sort_casts,\n  Cons,\n  Nil,\n  new_board,\n  cast,\n  print_board,\n  unit_to_scott,\n  get_skill_priority,\n  get_skill_area,\n  get_at,\n  end_turn,\n  skill_name,\n  hero_name,\n  unit_to_json,\n  board_to_json,\n  TOPHORO,\n  GONK,\n  STANCI,\n  HERO_03,\n  ERKOS,\n  CRONI,\n  SNARCH,\n  HERO_07,\n  SIRPIX,\n  KENLUA,\n  FLINA,\n  HERO_11,\n  ZAGATUR,\n  AGDRIS,\n  MEWEM,\n  HERO_15,\n};\n\n\n//# sourceURL=webpack:///./src/kaelin.js?");

/***/ }),

/***/ "./src/keyboard.js":
/*!*************************!*\
  !*** ./src/keyboard.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Keyboard\nconst Keyboard = (callbacks) => {\n  callbacks.down = callbacks.down || function(){};\n  callbacks.up = callbacks.up || function(){};\n  var key = {};\n  document.addEventListener(\"keydown\", e => { key[e.key] = 1; callbacks.down(e.key); });\n  document.addEventListener(\"keyup\", e => { key[e.key] = 0; callbacks.up(e.key); });\n  return key;\n};\n\nmodule.exports = Keyboard;\n\n\n//# sourceURL=webpack:///./src/keyboard.js?");

/***/ }),

/***/ "./src/parse_cast.js":
/*!***************************!*\
  !*** ./src/parse_cast.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const kaelin = __webpack_require__(/*! ./kaelin.js */ \"./src/kaelin.js\");\n\nconst parse_cast = (code) => {\n  const parse_hero = (str) => {\n    switch (str.toLowerCase()) {\n      case \"to\": var hero = kaelin.TOPHORO ; break;\n      case \"go\": var hero = kaelin.GONK    ; break;\n      case \"st\": var hero = kaelin.STANCI  ; break;\n      case \"h3\": var hero = kaelin.HERO_3  ; break;\n      case \"er\": var hero = kaelin.ERKOS   ; break;\n      case \"cr\": var hero = kaelin.CRONI   ; break;\n      case \"sn\": var hero = kaelin.SNARCH  ; break;\n      case \"h7\": var hero = kaelin.HERO_7  ; break;\n      case \"si\": var hero = kaelin.SIRPIX  ; break;\n      case \"ke\": var hero = kaelin.KENLUA  ; break;\n      case \"fl\": var hero = kaelin.FLINA   ; break;\n      case \"hb\": var hero = kaelin.HERO_B  ; break;\n      case \"za\": var hero = kaelin.ZAGATUR ; break;\n      case \"ag\": var hero = kaelin.AGDRIS  ; break;\n      case \"me\": var hero = kaelin.MEWEM   ; break;\n      case \"hf\": var hero = kaelin.HERO_F  ; break;\n      default: throw \"Invalid hero `\" + code.slice(0,2) + \"\\`.\";\n    }\n    return hero;\n  };\n\n  const parse_pos = (pos) => {\n    if (pos.length !== 2 || !/[0-9a-fA-F]/.test(pos[0]) || !/[0-9a-fA-F]/.test(pos[1])) {\n      throw \"Invalid position `\" + pos + \"`.\";\n    }\n    return [parseInt(pos[0], 16), parseInt(pos[1], 16)];\n  };\n\n  var words = code.split(\" \").slice(0, 5);\n  while (words.length < 5) {\n    words.push(\".\");\n  }\n\n  var hero = parse_hero(words[0]);\n  try { var walk = words[1] === \".\" ? null : parse_pos(words[1]); } catch (e) { throw e + \" (When parsing walk.)\"; }\n  try { var skl0 = words[2] === \".\" ? null : parse_pos(words[2]); } catch (e) { throw e + \" (When parsing skill 0.)\" };\n  try { var skl1 = words[3] === \".\" ? null : parse_pos(words[3]); } catch (e) { throw e + \" (When parsing skill 1.)\" };\n  try { var skl2 = words[4] === \".\" ? null : parse_pos(words[4]); } catch (e) { throw e + \" (When parsing skill 2.)\" };\n\n  return [[hero * 4 + 0, walk], [hero * 4 + 1, skl0], [hero * 4 + 2, skl1], [hero * 4 + 3, skl2]];\n};\n\nmodule.exports = parse_cast;\n\n\n//# sourceURL=webpack:///./src/parse_cast.js?");

/***/ })

/******/ });